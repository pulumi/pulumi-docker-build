// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package dockerbuild

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi-docker-build/sdk/go/dockerbuild/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumix"
)

var _ = internal.GetEnvOrDefault

type BuildContext struct {
	// Resources to use for build context.
	//
	// The location can be:
	// * A relative or absolute path to a local directory (`.`, `./app`,
	//   `/app`, etc.).
	// * A remote URL of a Git repository, tarball, or plain text file
	//   (`https://github.com/user/myrepo.git`, `http://server/context.tar.gz`,
	//   etc.).
	Location string `pulumi:"location"`
	// Additional build contexts to use.
	//
	// These contexts are accessed with `FROM name` or `--from=name`
	// statements when using Dockerfile 1.4+ syntax.
	//
	// Values can be local paths, HTTP URLs, or  `docker-image://` images.
	Named map[string]*Context `pulumi:"named"`
}

type BuildContextArgs struct {
	// Resources to use for build context.
	//
	// The location can be:
	// * A relative or absolute path to a local directory (`.`, `./app`,
	//   `/app`, etc.).
	// * A remote URL of a Git repository, tarball, or plain text file
	//   (`https://github.com/user/myrepo.git`, `http://server/context.tar.gz`,
	//   etc.).
	Location pulumix.Input[string] `pulumi:"location"`
	// Additional build contexts to use.
	//
	// These contexts are accessed with `FROM name` or `--from=name`
	// statements when using Dockerfile 1.4+ syntax.
	//
	// Values can be local paths, HTTP URLs, or  `docker-image://` images.
	Named pulumix.Input[map[string]*ContextArgs] `pulumi:"named"`
}

func (BuildContextArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BuildContext)(nil)).Elem()
}

func (i BuildContextArgs) ToBuildContextOutput() BuildContextOutput {
	return i.ToBuildContextOutputWithContext(context.Background())
}

func (i BuildContextArgs) ToBuildContextOutputWithContext(ctx context.Context) BuildContextOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BuildContextOutput)
}

func (i *BuildContextArgs) ToOutput(ctx context.Context) pulumix.Output[*BuildContextArgs] {
	return pulumix.Val(i)
}

type BuildContextOutput struct{ *pulumi.OutputState }

func (BuildContextOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BuildContext)(nil)).Elem()
}

func (o BuildContextOutput) ToBuildContextOutput() BuildContextOutput {
	return o
}

func (o BuildContextOutput) ToBuildContextOutputWithContext(ctx context.Context) BuildContextOutput {
	return o
}

func (o BuildContextOutput) ToOutput(ctx context.Context) pulumix.Output[BuildContext] {
	return pulumix.Output[BuildContext]{
		OutputState: o.OutputState,
	}
}

// Resources to use for build context.
//
// The location can be:
//   - A relative or absolute path to a local directory (`.`, `./app`,
//     `/app`, etc.).
//   - A remote URL of a Git repository, tarball, or plain text file
//     (`https://github.com/user/myrepo.git`, `http://server/context.tar.gz`,
//     etc.).
func (o BuildContextOutput) Location() pulumix.Output[string] {
	return pulumix.Apply[BuildContext](o, func(v BuildContext) string { return v.Location })
}

// Additional build contexts to use.
//
// These contexts are accessed with `FROM name` or `--from=name`
// statements when using Dockerfile 1.4+ syntax.
//
// Values can be local paths, HTTP URLs, or  `docker-image://` images.
func (o BuildContextOutput) Named() pulumix.GMapOutput[Context, ContextOutput] {
	value := pulumix.Apply[BuildContext](o, func(v BuildContext) map[string]*Context { return v.Named })
	return pulumix.GMapOutput[Context, ContextOutput]{OutputState: value.OutputState}
}

type BuilderConfig struct {
	// Name of an existing buildx builder to use.
	//
	// Only `docker-container`, `kubernetes`, or `remote` drivers are
	// supported. The legacy `docker` driver is not supported.
	//
	// Equivalent to Docker's `--builder` flag.
	Name *string `pulumi:"name"`
}

type BuilderConfigArgs struct {
	// Name of an existing buildx builder to use.
	//
	// Only `docker-container`, `kubernetes`, or `remote` drivers are
	// supported. The legacy `docker` driver is not supported.
	//
	// Equivalent to Docker's `--builder` flag.
	Name pulumix.Input[*string] `pulumi:"name"`
}

func (BuilderConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BuilderConfig)(nil)).Elem()
}

func (i BuilderConfigArgs) ToBuilderConfigOutput() BuilderConfigOutput {
	return i.ToBuilderConfigOutputWithContext(context.Background())
}

func (i BuilderConfigArgs) ToBuilderConfigOutputWithContext(ctx context.Context) BuilderConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BuilderConfigOutput)
}

func (i *BuilderConfigArgs) ToOutput(ctx context.Context) pulumix.Output[*BuilderConfigArgs] {
	return pulumix.Val(i)
}

type BuilderConfigOutput struct{ *pulumi.OutputState }

func (BuilderConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BuilderConfig)(nil)).Elem()
}

func (o BuilderConfigOutput) ToBuilderConfigOutput() BuilderConfigOutput {
	return o
}

func (o BuilderConfigOutput) ToBuilderConfigOutputWithContext(ctx context.Context) BuilderConfigOutput {
	return o
}

func (o BuilderConfigOutput) ToOutput(ctx context.Context) pulumix.Output[BuilderConfig] {
	return pulumix.Output[BuilderConfig]{
		OutputState: o.OutputState,
	}
}

// Name of an existing buildx builder to use.
//
// Only `docker-container`, `kubernetes`, or `remote` drivers are
// supported. The legacy `docker` driver is not supported.
//
// Equivalent to Docker's `--builder` flag.
func (o BuilderConfigOutput) Name() pulumix.Output[*string] {
	return pulumix.Apply[BuilderConfig](o, func(v BuilderConfig) *string { return v.Name })
}

type CacheFrom struct {
	// Upload build caches to Azure's blob storage service.
	Azblob *CacheFromAzureBlob `pulumi:"azblob"`
	// When `true` this entry will be excluded. Defaults to `false`.
	Disabled *bool `pulumi:"disabled"`
	// Recommended for use with GitHub Actions workflows.
	//
	// An action like `crazy-max/ghaction-github-runtime` is recommended to
	// expose appropriate credentials to your GitHub workflow.
	Gha *CacheFromGitHubActions `pulumi:"gha"`
	// A simple backend which caches images on your local filesystem.
	Local *CacheFromLocal `pulumi:"local"`
	// A raw string as you would provide it to the Docker CLI (e.g.,
	// `type=inline`).
	Raw *string `pulumi:"raw"`
	// Upload build caches to remote registries.
	Registry *CacheFromRegistry `pulumi:"registry"`
	// Upload build caches to AWS S3 or an S3-compatible services such as
	// MinIO.
	S3 *CacheFromS3 `pulumi:"s3"`
}

// Defaults sets the appropriate defaults for CacheFrom
func (val *CacheFrom) Defaults() *CacheFrom {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.Gha = tmp.Gha.Defaults()

	tmp.S3 = tmp.S3.Defaults()

	return &tmp
}

type CacheFromArgs struct {
	// Upload build caches to Azure's blob storage service.
	Azblob pulumix.Input[*CacheFromAzureBlobArgs] `pulumi:"azblob"`
	// When `true` this entry will be excluded. Defaults to `false`.
	Disabled pulumix.Input[*bool] `pulumi:"disabled"`
	// Recommended for use with GitHub Actions workflows.
	//
	// An action like `crazy-max/ghaction-github-runtime` is recommended to
	// expose appropriate credentials to your GitHub workflow.
	Gha pulumix.Input[*CacheFromGitHubActionsArgs] `pulumi:"gha"`
	// A simple backend which caches images on your local filesystem.
	Local pulumix.Input[*CacheFromLocalArgs] `pulumi:"local"`
	// A raw string as you would provide it to the Docker CLI (e.g.,
	// `type=inline`).
	Raw pulumix.Input[*string] `pulumi:"raw"`
	// Upload build caches to remote registries.
	Registry pulumix.Input[*CacheFromRegistryArgs] `pulumi:"registry"`
	// Upload build caches to AWS S3 or an S3-compatible services such as
	// MinIO.
	S3 pulumix.Input[*CacheFromS3Args] `pulumi:"s3"`
}

// Defaults sets the appropriate defaults for CacheFromArgs
func (val *CacheFromArgs) Defaults() *CacheFromArgs {
	if val == nil {
		return nil
	}
	tmp := *val

	return &tmp
}
func (CacheFromArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CacheFrom)(nil)).Elem()
}

func (i CacheFromArgs) ToCacheFromOutput() CacheFromOutput {
	return i.ToCacheFromOutputWithContext(context.Background())
}

func (i CacheFromArgs) ToCacheFromOutputWithContext(ctx context.Context) CacheFromOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CacheFromOutput)
}

func (i *CacheFromArgs) ToOutput(ctx context.Context) pulumix.Output[*CacheFromArgs] {
	return pulumix.Val(i)
}

type CacheFromOutput struct{ *pulumi.OutputState }

func (CacheFromOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CacheFrom)(nil)).Elem()
}

func (o CacheFromOutput) ToCacheFromOutput() CacheFromOutput {
	return o
}

func (o CacheFromOutput) ToCacheFromOutputWithContext(ctx context.Context) CacheFromOutput {
	return o
}

func (o CacheFromOutput) ToOutput(ctx context.Context) pulumix.Output[CacheFrom] {
	return pulumix.Output[CacheFrom]{
		OutputState: o.OutputState,
	}
}

// Upload build caches to Azure's blob storage service.
func (o CacheFromOutput) Azblob() pulumix.GPtrOutput[CacheFromAzureBlob, CacheFromAzureBlobOutput] {
	value := pulumix.Apply[CacheFrom](o, func(v CacheFrom) *CacheFromAzureBlob { return v.Azblob })
	return pulumix.GPtrOutput[CacheFromAzureBlob, CacheFromAzureBlobOutput]{OutputState: value.OutputState}
}

// When `true` this entry will be excluded. Defaults to `false`.
func (o CacheFromOutput) Disabled() pulumix.Output[*bool] {
	return pulumix.Apply[CacheFrom](o, func(v CacheFrom) *bool { return v.Disabled })
}

// Recommended for use with GitHub Actions workflows.
//
// An action like `crazy-max/ghaction-github-runtime` is recommended to
// expose appropriate credentials to your GitHub workflow.
func (o CacheFromOutput) Gha() pulumix.GPtrOutput[CacheFromGitHubActions, CacheFromGitHubActionsOutput] {
	value := pulumix.Apply[CacheFrom](o, func(v CacheFrom) *CacheFromGitHubActions { return v.Gha })
	return pulumix.GPtrOutput[CacheFromGitHubActions, CacheFromGitHubActionsOutput]{OutputState: value.OutputState}
}

// A simple backend which caches images on your local filesystem.
func (o CacheFromOutput) Local() pulumix.GPtrOutput[CacheFromLocal, CacheFromLocalOutput] {
	value := pulumix.Apply[CacheFrom](o, func(v CacheFrom) *CacheFromLocal { return v.Local })
	return pulumix.GPtrOutput[CacheFromLocal, CacheFromLocalOutput]{OutputState: value.OutputState}
}

// A raw string as you would provide it to the Docker CLI (e.g.,
// `type=inline`).
func (o CacheFromOutput) Raw() pulumix.Output[*string] {
	return pulumix.Apply[CacheFrom](o, func(v CacheFrom) *string { return v.Raw })
}

// Upload build caches to remote registries.
func (o CacheFromOutput) Registry() pulumix.GPtrOutput[CacheFromRegistry, CacheFromRegistryOutput] {
	value := pulumix.Apply[CacheFrom](o, func(v CacheFrom) *CacheFromRegistry { return v.Registry })
	return pulumix.GPtrOutput[CacheFromRegistry, CacheFromRegistryOutput]{OutputState: value.OutputState}
}

// Upload build caches to AWS S3 or an S3-compatible services such as
// MinIO.
func (o CacheFromOutput) S3() pulumix.GPtrOutput[CacheFromS3, CacheFromS3Output] {
	value := pulumix.Apply[CacheFrom](o, func(v CacheFrom) *CacheFromS3 { return v.S3 })
	return pulumix.GPtrOutput[CacheFromS3, CacheFromS3Output]{OutputState: value.OutputState}
}

type CacheFromAzureBlob struct {
	// Base URL of the storage account.
	AccountUrl *string `pulumi:"accountUrl"`
	// The name of the cache image.
	Name string `pulumi:"name"`
	// Blob storage account key.
	SecretAccessKey *string `pulumi:"secretAccessKey"`
}

type CacheFromAzureBlobArgs struct {
	// Base URL of the storage account.
	AccountUrl pulumix.Input[*string] `pulumi:"accountUrl"`
	// The name of the cache image.
	Name pulumix.Input[string] `pulumi:"name"`
	// Blob storage account key.
	SecretAccessKey pulumix.Input[*string] `pulumi:"secretAccessKey"`
}

func (CacheFromAzureBlobArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CacheFromAzureBlob)(nil)).Elem()
}

func (i CacheFromAzureBlobArgs) ToCacheFromAzureBlobOutput() CacheFromAzureBlobOutput {
	return i.ToCacheFromAzureBlobOutputWithContext(context.Background())
}

func (i CacheFromAzureBlobArgs) ToCacheFromAzureBlobOutputWithContext(ctx context.Context) CacheFromAzureBlobOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CacheFromAzureBlobOutput)
}

func (i *CacheFromAzureBlobArgs) ToOutput(ctx context.Context) pulumix.Output[*CacheFromAzureBlobArgs] {
	return pulumix.Val(i)
}

type CacheFromAzureBlobOutput struct{ *pulumi.OutputState }

func (CacheFromAzureBlobOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CacheFromAzureBlob)(nil)).Elem()
}

func (o CacheFromAzureBlobOutput) ToCacheFromAzureBlobOutput() CacheFromAzureBlobOutput {
	return o
}

func (o CacheFromAzureBlobOutput) ToCacheFromAzureBlobOutputWithContext(ctx context.Context) CacheFromAzureBlobOutput {
	return o
}

func (o CacheFromAzureBlobOutput) ToOutput(ctx context.Context) pulumix.Output[CacheFromAzureBlob] {
	return pulumix.Output[CacheFromAzureBlob]{
		OutputState: o.OutputState,
	}
}

// Base URL of the storage account.
func (o CacheFromAzureBlobOutput) AccountUrl() pulumix.Output[*string] {
	return pulumix.Apply[CacheFromAzureBlob](o, func(v CacheFromAzureBlob) *string { return v.AccountUrl })
}

// The name of the cache image.
func (o CacheFromAzureBlobOutput) Name() pulumix.Output[string] {
	return pulumix.Apply[CacheFromAzureBlob](o, func(v CacheFromAzureBlob) string { return v.Name })
}

// Blob storage account key.
func (o CacheFromAzureBlobOutput) SecretAccessKey() pulumix.Output[*string] {
	return pulumix.Apply[CacheFromAzureBlob](o, func(v CacheFromAzureBlob) *string { return v.SecretAccessKey })
}

type CacheFromGitHubActions struct {
	// The scope to use for cache keys. Defaults to `buildkit`.
	//
	// This should be set if building and caching multiple images in one
	// workflow, otherwise caches will overwrite each other.
	Scope *string `pulumi:"scope"`
	// The GitHub Actions token to use. This is not a personal access tokens
	// and is typically generated automatically as part of each job.
	//
	// Defaults to `$ACTIONS_RUNTIME_TOKEN`, although a separate action like
	// `crazy-max/ghaction-github-runtime` is recommended to expose this
	// environment variable to your jobs.
	Token *string `pulumi:"token"`
	// The cache server URL to use for artifacts.
	//
	// Defaults to `$ACTIONS_CACHE_URL`, although a separate action like
	// `crazy-max/ghaction-github-runtime` is recommended to expose this
	// environment variable to your jobs.
	Url *string `pulumi:"url"`
}

// Defaults sets the appropriate defaults for CacheFromGitHubActions
func (val *CacheFromGitHubActions) Defaults() *CacheFromGitHubActions {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Scope == nil {
		if d := internal.GetEnvOrDefault("", nil, "buildkit"); d != nil {
			scope_ := d.(string)
			tmp.Scope = &scope_
		}
	}
	if tmp.Token == nil {
		if d := internal.GetEnvOrDefault("", nil, "ACTIONS_RUNTIME_TOKEN"); d != nil {
			token_ := d.(string)
			tmp.Token = &token_
		}
	}
	if tmp.Url == nil {
		if d := internal.GetEnvOrDefault("", nil, "ACTIONS_CACHE_URL"); d != nil {
			url_ := d.(string)
			tmp.Url = &url_
		}
	}
	return &tmp
}

type CacheFromGitHubActionsArgs struct {
	// The scope to use for cache keys. Defaults to `buildkit`.
	//
	// This should be set if building and caching multiple images in one
	// workflow, otherwise caches will overwrite each other.
	Scope pulumix.Input[*string] `pulumi:"scope"`
	// The GitHub Actions token to use. This is not a personal access tokens
	// and is typically generated automatically as part of each job.
	//
	// Defaults to `$ACTIONS_RUNTIME_TOKEN`, although a separate action like
	// `crazy-max/ghaction-github-runtime` is recommended to expose this
	// environment variable to your jobs.
	Token pulumix.Input[*string] `pulumi:"token"`
	// The cache server URL to use for artifacts.
	//
	// Defaults to `$ACTIONS_CACHE_URL`, although a separate action like
	// `crazy-max/ghaction-github-runtime` is recommended to expose this
	// environment variable to your jobs.
	Url pulumix.Input[*string] `pulumi:"url"`
}

// Defaults sets the appropriate defaults for CacheFromGitHubActionsArgs
func (val *CacheFromGitHubActionsArgs) Defaults() *CacheFromGitHubActionsArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Scope == nil {
		if d := internal.GetEnvOrDefault("", nil, "buildkit"); d != nil {
			tmp.Scope = pulumix.Ptr(d.(string))
		}
	}
	if tmp.Token == nil {
		if d := internal.GetEnvOrDefault("", nil, "ACTIONS_RUNTIME_TOKEN"); d != nil {
			tmp.Token = pulumix.Ptr(d.(string))
		}
	}
	if tmp.Url == nil {
		if d := internal.GetEnvOrDefault("", nil, "ACTIONS_CACHE_URL"); d != nil {
			tmp.Url = pulumix.Ptr(d.(string))
		}
	}
	return &tmp
}
func (CacheFromGitHubActionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CacheFromGitHubActions)(nil)).Elem()
}

func (i CacheFromGitHubActionsArgs) ToCacheFromGitHubActionsOutput() CacheFromGitHubActionsOutput {
	return i.ToCacheFromGitHubActionsOutputWithContext(context.Background())
}

func (i CacheFromGitHubActionsArgs) ToCacheFromGitHubActionsOutputWithContext(ctx context.Context) CacheFromGitHubActionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CacheFromGitHubActionsOutput)
}

func (i *CacheFromGitHubActionsArgs) ToOutput(ctx context.Context) pulumix.Output[*CacheFromGitHubActionsArgs] {
	return pulumix.Val(i)
}

type CacheFromGitHubActionsOutput struct{ *pulumi.OutputState }

func (CacheFromGitHubActionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CacheFromGitHubActions)(nil)).Elem()
}

func (o CacheFromGitHubActionsOutput) ToCacheFromGitHubActionsOutput() CacheFromGitHubActionsOutput {
	return o
}

func (o CacheFromGitHubActionsOutput) ToCacheFromGitHubActionsOutputWithContext(ctx context.Context) CacheFromGitHubActionsOutput {
	return o
}

func (o CacheFromGitHubActionsOutput) ToOutput(ctx context.Context) pulumix.Output[CacheFromGitHubActions] {
	return pulumix.Output[CacheFromGitHubActions]{
		OutputState: o.OutputState,
	}
}

// The scope to use for cache keys. Defaults to `buildkit`.
//
// This should be set if building and caching multiple images in one
// workflow, otherwise caches will overwrite each other.
func (o CacheFromGitHubActionsOutput) Scope() pulumix.Output[*string] {
	return pulumix.Apply[CacheFromGitHubActions](o, func(v CacheFromGitHubActions) *string { return v.Scope })
}

// The GitHub Actions token to use. This is not a personal access tokens
// and is typically generated automatically as part of each job.
//
// Defaults to `$ACTIONS_RUNTIME_TOKEN`, although a separate action like
// `crazy-max/ghaction-github-runtime` is recommended to expose this
// environment variable to your jobs.
func (o CacheFromGitHubActionsOutput) Token() pulumix.Output[*string] {
	return pulumix.Apply[CacheFromGitHubActions](o, func(v CacheFromGitHubActions) *string { return v.Token })
}

// The cache server URL to use for artifacts.
//
// Defaults to `$ACTIONS_CACHE_URL`, although a separate action like
// `crazy-max/ghaction-github-runtime` is recommended to expose this
// environment variable to your jobs.
func (o CacheFromGitHubActionsOutput) Url() pulumix.Output[*string] {
	return pulumix.Apply[CacheFromGitHubActions](o, func(v CacheFromGitHubActions) *string { return v.Url })
}

type CacheFromLocal struct {
	// Digest of manifest to import.
	Digest *string `pulumi:"digest"`
	// Path of the local directory where cache gets imported from.
	Src string `pulumi:"src"`
}

type CacheFromLocalArgs struct {
	// Digest of manifest to import.
	Digest pulumix.Input[*string] `pulumi:"digest"`
	// Path of the local directory where cache gets imported from.
	Src pulumix.Input[string] `pulumi:"src"`
}

func (CacheFromLocalArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CacheFromLocal)(nil)).Elem()
}

func (i CacheFromLocalArgs) ToCacheFromLocalOutput() CacheFromLocalOutput {
	return i.ToCacheFromLocalOutputWithContext(context.Background())
}

func (i CacheFromLocalArgs) ToCacheFromLocalOutputWithContext(ctx context.Context) CacheFromLocalOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CacheFromLocalOutput)
}

func (i *CacheFromLocalArgs) ToOutput(ctx context.Context) pulumix.Output[*CacheFromLocalArgs] {
	return pulumix.Val(i)
}

type CacheFromLocalOutput struct{ *pulumi.OutputState }

func (CacheFromLocalOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CacheFromLocal)(nil)).Elem()
}

func (o CacheFromLocalOutput) ToCacheFromLocalOutput() CacheFromLocalOutput {
	return o
}

func (o CacheFromLocalOutput) ToCacheFromLocalOutputWithContext(ctx context.Context) CacheFromLocalOutput {
	return o
}

func (o CacheFromLocalOutput) ToOutput(ctx context.Context) pulumix.Output[CacheFromLocal] {
	return pulumix.Output[CacheFromLocal]{
		OutputState: o.OutputState,
	}
}

// Digest of manifest to import.
func (o CacheFromLocalOutput) Digest() pulumix.Output[*string] {
	return pulumix.Apply[CacheFromLocal](o, func(v CacheFromLocal) *string { return v.Digest })
}

// Path of the local directory where cache gets imported from.
func (o CacheFromLocalOutput) Src() pulumix.Output[string] {
	return pulumix.Apply[CacheFromLocal](o, func(v CacheFromLocal) string { return v.Src })
}

type CacheFromRegistry struct {
	// Fully qualified name of the cache image to import.
	Ref string `pulumi:"ref"`
}

type CacheFromRegistryArgs struct {
	// Fully qualified name of the cache image to import.
	Ref pulumix.Input[string] `pulumi:"ref"`
}

func (CacheFromRegistryArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CacheFromRegistry)(nil)).Elem()
}

func (i CacheFromRegistryArgs) ToCacheFromRegistryOutput() CacheFromRegistryOutput {
	return i.ToCacheFromRegistryOutputWithContext(context.Background())
}

func (i CacheFromRegistryArgs) ToCacheFromRegistryOutputWithContext(ctx context.Context) CacheFromRegistryOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CacheFromRegistryOutput)
}

func (i *CacheFromRegistryArgs) ToOutput(ctx context.Context) pulumix.Output[*CacheFromRegistryArgs] {
	return pulumix.Val(i)
}

type CacheFromRegistryOutput struct{ *pulumi.OutputState }

func (CacheFromRegistryOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CacheFromRegistry)(nil)).Elem()
}

func (o CacheFromRegistryOutput) ToCacheFromRegistryOutput() CacheFromRegistryOutput {
	return o
}

func (o CacheFromRegistryOutput) ToCacheFromRegistryOutputWithContext(ctx context.Context) CacheFromRegistryOutput {
	return o
}

func (o CacheFromRegistryOutput) ToOutput(ctx context.Context) pulumix.Output[CacheFromRegistry] {
	return pulumix.Output[CacheFromRegistry]{
		OutputState: o.OutputState,
	}
}

// Fully qualified name of the cache image to import.
func (o CacheFromRegistryOutput) Ref() pulumix.Output[string] {
	return pulumix.Apply[CacheFromRegistry](o, func(v CacheFromRegistry) string { return v.Ref })
}

type CacheFromS3 struct {
	// Defaults to `$AWS_ACCESS_KEY_ID`.
	AccessKeyId *string `pulumi:"accessKeyId"`
	// Prefix to prepend to blob filenames.
	BlobsPrefix *string `pulumi:"blobsPrefix"`
	// Name of the S3 bucket.
	Bucket string `pulumi:"bucket"`
	// Endpoint of the S3 bucket.
	EndpointUrl *string `pulumi:"endpointUrl"`
	// Prefix to prepend on manifest filenames.
	ManifestsPrefix *string `pulumi:"manifestsPrefix"`
	// Name of the cache image.
	Name *string `pulumi:"name"`
	// The geographic location of the bucket. Defaults to `$AWS_REGION`.
	Region string `pulumi:"region"`
	// Defaults to `$AWS_SECRET_ACCESS_KEY`.
	SecretAccessKey *string `pulumi:"secretAccessKey"`
	// Defaults to `$AWS_SESSION_TOKEN`.
	SessionToken *string `pulumi:"sessionToken"`
	// Uses `bucket` in the URL instead of hostname when `true`.
	UsePathStyle *bool `pulumi:"usePathStyle"`
}

// Defaults sets the appropriate defaults for CacheFromS3
func (val *CacheFromS3) Defaults() *CacheFromS3 {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.AccessKeyId == nil {
		if d := internal.GetEnvOrDefault("", nil, "AWS_ACCESS_KEY_ID"); d != nil {
			accessKeyId_ := d.(string)
			tmp.AccessKeyId = &accessKeyId_
		}
	}
	if internal.IsZero(tmp.Region) {
		if d := internal.GetEnvOrDefault("", nil, "AWS_REGION"); d != nil {
			tmp.Region = d.(string)
		}
	}
	if tmp.SecretAccessKey == nil {
		if d := internal.GetEnvOrDefault("", nil, "AWS_SECRET_ACCESS_KEY"); d != nil {
			secretAccessKey_ := d.(string)
			tmp.SecretAccessKey = &secretAccessKey_
		}
	}
	if tmp.SessionToken == nil {
		if d := internal.GetEnvOrDefault("", nil, "AWS_SESSION_TOKEN"); d != nil {
			sessionToken_ := d.(string)
			tmp.SessionToken = &sessionToken_
		}
	}
	return &tmp
}

type CacheFromS3Args struct {
	// Defaults to `$AWS_ACCESS_KEY_ID`.
	AccessKeyId pulumix.Input[*string] `pulumi:"accessKeyId"`
	// Prefix to prepend to blob filenames.
	BlobsPrefix pulumix.Input[*string] `pulumi:"blobsPrefix"`
	// Name of the S3 bucket.
	Bucket pulumix.Input[string] `pulumi:"bucket"`
	// Endpoint of the S3 bucket.
	EndpointUrl pulumix.Input[*string] `pulumi:"endpointUrl"`
	// Prefix to prepend on manifest filenames.
	ManifestsPrefix pulumix.Input[*string] `pulumi:"manifestsPrefix"`
	// Name of the cache image.
	Name pulumix.Input[*string] `pulumi:"name"`
	// The geographic location of the bucket. Defaults to `$AWS_REGION`.
	Region pulumix.Input[string] `pulumi:"region"`
	// Defaults to `$AWS_SECRET_ACCESS_KEY`.
	SecretAccessKey pulumix.Input[*string] `pulumi:"secretAccessKey"`
	// Defaults to `$AWS_SESSION_TOKEN`.
	SessionToken pulumix.Input[*string] `pulumi:"sessionToken"`
	// Uses `bucket` in the URL instead of hostname when `true`.
	UsePathStyle pulumix.Input[*bool] `pulumi:"usePathStyle"`
}

// Defaults sets the appropriate defaults for CacheFromS3Args
func (val *CacheFromS3Args) Defaults() *CacheFromS3Args {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.AccessKeyId == nil {
		if d := internal.GetEnvOrDefault("", nil, "AWS_ACCESS_KEY_ID"); d != nil {
			tmp.AccessKeyId = pulumix.Ptr(d.(string))
		}
	}
	if tmp.Region == nil {
		if d := internal.GetEnvOrDefault("", nil, "AWS_REGION"); d != nil {
			tmp.Region = pulumix.Val(d.(string))
		}
	}
	if tmp.SecretAccessKey == nil {
		if d := internal.GetEnvOrDefault("", nil, "AWS_SECRET_ACCESS_KEY"); d != nil {
			tmp.SecretAccessKey = pulumix.Ptr(d.(string))
		}
	}
	if tmp.SessionToken == nil {
		if d := internal.GetEnvOrDefault("", nil, "AWS_SESSION_TOKEN"); d != nil {
			tmp.SessionToken = pulumix.Ptr(d.(string))
		}
	}
	return &tmp
}
func (CacheFromS3Args) ElementType() reflect.Type {
	return reflect.TypeOf((*CacheFromS3)(nil)).Elem()
}

func (i CacheFromS3Args) ToCacheFromS3Output() CacheFromS3Output {
	return i.ToCacheFromS3OutputWithContext(context.Background())
}

func (i CacheFromS3Args) ToCacheFromS3OutputWithContext(ctx context.Context) CacheFromS3Output {
	return pulumi.ToOutputWithContext(ctx, i).(CacheFromS3Output)
}

func (i *CacheFromS3Args) ToOutput(ctx context.Context) pulumix.Output[*CacheFromS3Args] {
	return pulumix.Val(i)
}

type CacheFromS3Output struct{ *pulumi.OutputState }

func (CacheFromS3Output) ElementType() reflect.Type {
	return reflect.TypeOf((*CacheFromS3)(nil)).Elem()
}

func (o CacheFromS3Output) ToCacheFromS3Output() CacheFromS3Output {
	return o
}

func (o CacheFromS3Output) ToCacheFromS3OutputWithContext(ctx context.Context) CacheFromS3Output {
	return o
}

func (o CacheFromS3Output) ToOutput(ctx context.Context) pulumix.Output[CacheFromS3] {
	return pulumix.Output[CacheFromS3]{
		OutputState: o.OutputState,
	}
}

// Defaults to `$AWS_ACCESS_KEY_ID`.
func (o CacheFromS3Output) AccessKeyId() pulumix.Output[*string] {
	return pulumix.Apply[CacheFromS3](o, func(v CacheFromS3) *string { return v.AccessKeyId })
}

// Prefix to prepend to blob filenames.
func (o CacheFromS3Output) BlobsPrefix() pulumix.Output[*string] {
	return pulumix.Apply[CacheFromS3](o, func(v CacheFromS3) *string { return v.BlobsPrefix })
}

// Name of the S3 bucket.
func (o CacheFromS3Output) Bucket() pulumix.Output[string] {
	return pulumix.Apply[CacheFromS3](o, func(v CacheFromS3) string { return v.Bucket })
}

// Endpoint of the S3 bucket.
func (o CacheFromS3Output) EndpointUrl() pulumix.Output[*string] {
	return pulumix.Apply[CacheFromS3](o, func(v CacheFromS3) *string { return v.EndpointUrl })
}

// Prefix to prepend on manifest filenames.
func (o CacheFromS3Output) ManifestsPrefix() pulumix.Output[*string] {
	return pulumix.Apply[CacheFromS3](o, func(v CacheFromS3) *string { return v.ManifestsPrefix })
}

// Name of the cache image.
func (o CacheFromS3Output) Name() pulumix.Output[*string] {
	return pulumix.Apply[CacheFromS3](o, func(v CacheFromS3) *string { return v.Name })
}

// The geographic location of the bucket. Defaults to `$AWS_REGION`.
func (o CacheFromS3Output) Region() pulumix.Output[string] {
	return pulumix.Apply[CacheFromS3](o, func(v CacheFromS3) string { return v.Region })
}

// Defaults to `$AWS_SECRET_ACCESS_KEY`.
func (o CacheFromS3Output) SecretAccessKey() pulumix.Output[*string] {
	return pulumix.Apply[CacheFromS3](o, func(v CacheFromS3) *string { return v.SecretAccessKey })
}

// Defaults to `$AWS_SESSION_TOKEN`.
func (o CacheFromS3Output) SessionToken() pulumix.Output[*string] {
	return pulumix.Apply[CacheFromS3](o, func(v CacheFromS3) *string { return v.SessionToken })
}

// Uses `bucket` in the URL instead of hostname when `true`.
func (o CacheFromS3Output) UsePathStyle() pulumix.Output[*bool] {
	return pulumix.Apply[CacheFromS3](o, func(v CacheFromS3) *bool { return v.UsePathStyle })
}

type CacheTo struct {
	// Push cache to Azure's blob storage service.
	Azblob *CacheToAzureBlob `pulumi:"azblob"`
	// When `true` this entry will be excluded. Defaults to `false`.
	Disabled *bool `pulumi:"disabled"`
	// Recommended for use with GitHub Actions workflows.
	//
	// An action like `crazy-max/ghaction-github-runtime` is recommended to
	// expose appropriate credentials to your GitHub workflow.
	Gha *CacheToGitHubActions `pulumi:"gha"`
	// The inline cache storage backend is the simplest implementation to get
	// started with, but it does not handle multi-stage builds. Consider the
	// `registry` cache backend instead.
	Inline *CacheToInline `pulumi:"inline"`
	// A simple backend which caches imagines on your local filesystem.
	Local *CacheToLocal `pulumi:"local"`
	// A raw string as you would provide it to the Docker CLI (e.g.,
	// `type=inline`)
	Raw *string `pulumi:"raw"`
	// Push caches to remote registries. Incompatible with the `docker` build
	// driver.
	Registry *CacheToRegistry `pulumi:"registry"`
	// Push cache to AWS S3 or S3-compatible services such as MinIO.
	S3 *CacheToS3 `pulumi:"s3"`
}

// Defaults sets the appropriate defaults for CacheTo
func (val *CacheTo) Defaults() *CacheTo {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.Azblob = tmp.Azblob.Defaults()

	tmp.Gha = tmp.Gha.Defaults()

	tmp.Local = tmp.Local.Defaults()

	tmp.Registry = tmp.Registry.Defaults()

	tmp.S3 = tmp.S3.Defaults()

	return &tmp
}

type CacheToArgs struct {
	// Push cache to Azure's blob storage service.
	Azblob pulumix.Input[*CacheToAzureBlobArgs] `pulumi:"azblob"`
	// When `true` this entry will be excluded. Defaults to `false`.
	Disabled pulumix.Input[*bool] `pulumi:"disabled"`
	// Recommended for use with GitHub Actions workflows.
	//
	// An action like `crazy-max/ghaction-github-runtime` is recommended to
	// expose appropriate credentials to your GitHub workflow.
	Gha pulumix.Input[*CacheToGitHubActionsArgs] `pulumi:"gha"`
	// The inline cache storage backend is the simplest implementation to get
	// started with, but it does not handle multi-stage builds. Consider the
	// `registry` cache backend instead.
	Inline pulumix.Input[*CacheToInlineArgs] `pulumi:"inline"`
	// A simple backend which caches imagines on your local filesystem.
	Local pulumix.Input[*CacheToLocalArgs] `pulumi:"local"`
	// A raw string as you would provide it to the Docker CLI (e.g.,
	// `type=inline`)
	Raw pulumix.Input[*string] `pulumi:"raw"`
	// Push caches to remote registries. Incompatible with the `docker` build
	// driver.
	Registry pulumix.Input[*CacheToRegistryArgs] `pulumi:"registry"`
	// Push cache to AWS S3 or S3-compatible services such as MinIO.
	S3 pulumix.Input[*CacheToS3Args] `pulumi:"s3"`
}

// Defaults sets the appropriate defaults for CacheToArgs
func (val *CacheToArgs) Defaults() *CacheToArgs {
	if val == nil {
		return nil
	}
	tmp := *val

	return &tmp
}
func (CacheToArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CacheTo)(nil)).Elem()
}

func (i CacheToArgs) ToCacheToOutput() CacheToOutput {
	return i.ToCacheToOutputWithContext(context.Background())
}

func (i CacheToArgs) ToCacheToOutputWithContext(ctx context.Context) CacheToOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CacheToOutput)
}

func (i *CacheToArgs) ToOutput(ctx context.Context) pulumix.Output[*CacheToArgs] {
	return pulumix.Val(i)
}

type CacheToOutput struct{ *pulumi.OutputState }

func (CacheToOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CacheTo)(nil)).Elem()
}

func (o CacheToOutput) ToCacheToOutput() CacheToOutput {
	return o
}

func (o CacheToOutput) ToCacheToOutputWithContext(ctx context.Context) CacheToOutput {
	return o
}

func (o CacheToOutput) ToOutput(ctx context.Context) pulumix.Output[CacheTo] {
	return pulumix.Output[CacheTo]{
		OutputState: o.OutputState,
	}
}

// Push cache to Azure's blob storage service.
func (o CacheToOutput) Azblob() pulumix.GPtrOutput[CacheToAzureBlob, CacheToAzureBlobOutput] {
	value := pulumix.Apply[CacheTo](o, func(v CacheTo) *CacheToAzureBlob { return v.Azblob })
	return pulumix.GPtrOutput[CacheToAzureBlob, CacheToAzureBlobOutput]{OutputState: value.OutputState}
}

// When `true` this entry will be excluded. Defaults to `false`.
func (o CacheToOutput) Disabled() pulumix.Output[*bool] {
	return pulumix.Apply[CacheTo](o, func(v CacheTo) *bool { return v.Disabled })
}

// Recommended for use with GitHub Actions workflows.
//
// An action like `crazy-max/ghaction-github-runtime` is recommended to
// expose appropriate credentials to your GitHub workflow.
func (o CacheToOutput) Gha() pulumix.GPtrOutput[CacheToGitHubActions, CacheToGitHubActionsOutput] {
	value := pulumix.Apply[CacheTo](o, func(v CacheTo) *CacheToGitHubActions { return v.Gha })
	return pulumix.GPtrOutput[CacheToGitHubActions, CacheToGitHubActionsOutput]{OutputState: value.OutputState}
}

// The inline cache storage backend is the simplest implementation to get
// started with, but it does not handle multi-stage builds. Consider the
// `registry` cache backend instead.
func (o CacheToOutput) Inline() pulumix.GPtrOutput[CacheToInline, CacheToInlineOutput] {
	value := pulumix.Apply[CacheTo](o, func(v CacheTo) *CacheToInline { return v.Inline })
	return pulumix.GPtrOutput[CacheToInline, CacheToInlineOutput]{OutputState: value.OutputState}
}

// A simple backend which caches imagines on your local filesystem.
func (o CacheToOutput) Local() pulumix.GPtrOutput[CacheToLocal, CacheToLocalOutput] {
	value := pulumix.Apply[CacheTo](o, func(v CacheTo) *CacheToLocal { return v.Local })
	return pulumix.GPtrOutput[CacheToLocal, CacheToLocalOutput]{OutputState: value.OutputState}
}

// A raw string as you would provide it to the Docker CLI (e.g.,
// `type=inline`)
func (o CacheToOutput) Raw() pulumix.Output[*string] {
	return pulumix.Apply[CacheTo](o, func(v CacheTo) *string { return v.Raw })
}

// Push caches to remote registries. Incompatible with the `docker` build
// driver.
func (o CacheToOutput) Registry() pulumix.GPtrOutput[CacheToRegistry, CacheToRegistryOutput] {
	value := pulumix.Apply[CacheTo](o, func(v CacheTo) *CacheToRegistry { return v.Registry })
	return pulumix.GPtrOutput[CacheToRegistry, CacheToRegistryOutput]{OutputState: value.OutputState}
}

// Push cache to AWS S3 or S3-compatible services such as MinIO.
func (o CacheToOutput) S3() pulumix.GPtrOutput[CacheToS3, CacheToS3Output] {
	value := pulumix.Apply[CacheTo](o, func(v CacheTo) *CacheToS3 { return v.S3 })
	return pulumix.GPtrOutput[CacheToS3, CacheToS3Output]{OutputState: value.OutputState}
}

type CacheToAzureBlob struct {
	// Base URL of the storage account.
	AccountUrl *string `pulumi:"accountUrl"`
	// Ignore errors caused by failed cache exports.
	IgnoreError *bool `pulumi:"ignoreError"`
	// The cache mode to use. Defaults to `min`.
	Mode *CacheMode `pulumi:"mode"`
	// The name of the cache image.
	Name string `pulumi:"name"`
	// Blob storage account key.
	SecretAccessKey *string `pulumi:"secretAccessKey"`
}

// Defaults sets the appropriate defaults for CacheToAzureBlob
func (val *CacheToAzureBlob) Defaults() *CacheToAzureBlob {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.IgnoreError == nil {
		ignoreError_ := false
		tmp.IgnoreError = &ignoreError_
	}
	if tmp.Mode == nil {
		mode_ := CacheMode("min")
		tmp.Mode = &mode_
	}
	return &tmp
}

type CacheToAzureBlobArgs struct {
	// Base URL of the storage account.
	AccountUrl pulumix.Input[*string] `pulumi:"accountUrl"`
	// Ignore errors caused by failed cache exports.
	IgnoreError pulumix.Input[*bool] `pulumi:"ignoreError"`
	// The cache mode to use. Defaults to `min`.
	Mode pulumix.Input[*CacheMode] `pulumi:"mode"`
	// The name of the cache image.
	Name pulumix.Input[string] `pulumi:"name"`
	// Blob storage account key.
	SecretAccessKey pulumix.Input[*string] `pulumi:"secretAccessKey"`
}

// Defaults sets the appropriate defaults for CacheToAzureBlobArgs
func (val *CacheToAzureBlobArgs) Defaults() *CacheToAzureBlobArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.IgnoreError == nil {
		tmp.IgnoreError = pulumix.Ptr(false)
	}
	if tmp.Mode == nil {
		tmp.Mode = pulumix.Ptr(CacheMode("min"))
	}
	return &tmp
}
func (CacheToAzureBlobArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CacheToAzureBlob)(nil)).Elem()
}

func (i CacheToAzureBlobArgs) ToCacheToAzureBlobOutput() CacheToAzureBlobOutput {
	return i.ToCacheToAzureBlobOutputWithContext(context.Background())
}

func (i CacheToAzureBlobArgs) ToCacheToAzureBlobOutputWithContext(ctx context.Context) CacheToAzureBlobOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CacheToAzureBlobOutput)
}

func (i *CacheToAzureBlobArgs) ToOutput(ctx context.Context) pulumix.Output[*CacheToAzureBlobArgs] {
	return pulumix.Val(i)
}

type CacheToAzureBlobOutput struct{ *pulumi.OutputState }

func (CacheToAzureBlobOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CacheToAzureBlob)(nil)).Elem()
}

func (o CacheToAzureBlobOutput) ToCacheToAzureBlobOutput() CacheToAzureBlobOutput {
	return o
}

func (o CacheToAzureBlobOutput) ToCacheToAzureBlobOutputWithContext(ctx context.Context) CacheToAzureBlobOutput {
	return o
}

func (o CacheToAzureBlobOutput) ToOutput(ctx context.Context) pulumix.Output[CacheToAzureBlob] {
	return pulumix.Output[CacheToAzureBlob]{
		OutputState: o.OutputState,
	}
}

// Base URL of the storage account.
func (o CacheToAzureBlobOutput) AccountUrl() pulumix.Output[*string] {
	return pulumix.Apply[CacheToAzureBlob](o, func(v CacheToAzureBlob) *string { return v.AccountUrl })
}

// Ignore errors caused by failed cache exports.
func (o CacheToAzureBlobOutput) IgnoreError() pulumix.Output[*bool] {
	return pulumix.Apply[CacheToAzureBlob](o, func(v CacheToAzureBlob) *bool { return v.IgnoreError })
}

// The cache mode to use. Defaults to `min`.
func (o CacheToAzureBlobOutput) Mode() pulumix.Output[*CacheMode] {
	return pulumix.Apply[CacheToAzureBlob](o, func(v CacheToAzureBlob) *CacheMode { return v.Mode })
}

// The name of the cache image.
func (o CacheToAzureBlobOutput) Name() pulumix.Output[string] {
	return pulumix.Apply[CacheToAzureBlob](o, func(v CacheToAzureBlob) string { return v.Name })
}

// Blob storage account key.
func (o CacheToAzureBlobOutput) SecretAccessKey() pulumix.Output[*string] {
	return pulumix.Apply[CacheToAzureBlob](o, func(v CacheToAzureBlob) *string { return v.SecretAccessKey })
}

type CacheToGitHubActions struct {
	// Ignore errors caused by failed cache exports.
	IgnoreError *bool `pulumi:"ignoreError"`
	// The cache mode to use. Defaults to `min`.
	Mode *CacheMode `pulumi:"mode"`
	// The scope to use for cache keys. Defaults to `buildkit`.
	//
	// This should be set if building and caching multiple images in one
	// workflow, otherwise caches will overwrite each other.
	Scope *string `pulumi:"scope"`
	// The GitHub Actions token to use. This is not a personal access tokens
	// and is typically generated automatically as part of each job.
	//
	// Defaults to `$ACTIONS_RUNTIME_TOKEN`, although a separate action like
	// `crazy-max/ghaction-github-runtime` is recommended to expose this
	// environment variable to your jobs.
	Token *string `pulumi:"token"`
	// The cache server URL to use for artifacts.
	//
	// Defaults to `$ACTIONS_CACHE_URL`, although a separate action like
	// `crazy-max/ghaction-github-runtime` is recommended to expose this
	// environment variable to your jobs.
	Url *string `pulumi:"url"`
}

// Defaults sets the appropriate defaults for CacheToGitHubActions
func (val *CacheToGitHubActions) Defaults() *CacheToGitHubActions {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.IgnoreError == nil {
		ignoreError_ := false
		tmp.IgnoreError = &ignoreError_
	}
	if tmp.Mode == nil {
		mode_ := CacheMode("min")
		tmp.Mode = &mode_
	}
	if tmp.Scope == nil {
		if d := internal.GetEnvOrDefault("", nil, "buildkit"); d != nil {
			scope_ := d.(string)
			tmp.Scope = &scope_
		}
	}
	if tmp.Token == nil {
		if d := internal.GetEnvOrDefault("", nil, "ACTIONS_RUNTIME_TOKEN"); d != nil {
			token_ := d.(string)
			tmp.Token = &token_
		}
	}
	if tmp.Url == nil {
		if d := internal.GetEnvOrDefault("", nil, "ACTIONS_CACHE_URL"); d != nil {
			url_ := d.(string)
			tmp.Url = &url_
		}
	}
	return &tmp
}

type CacheToGitHubActionsArgs struct {
	// Ignore errors caused by failed cache exports.
	IgnoreError pulumix.Input[*bool] `pulumi:"ignoreError"`
	// The cache mode to use. Defaults to `min`.
	Mode pulumix.Input[*CacheMode] `pulumi:"mode"`
	// The scope to use for cache keys. Defaults to `buildkit`.
	//
	// This should be set if building and caching multiple images in one
	// workflow, otherwise caches will overwrite each other.
	Scope pulumix.Input[*string] `pulumi:"scope"`
	// The GitHub Actions token to use. This is not a personal access tokens
	// and is typically generated automatically as part of each job.
	//
	// Defaults to `$ACTIONS_RUNTIME_TOKEN`, although a separate action like
	// `crazy-max/ghaction-github-runtime` is recommended to expose this
	// environment variable to your jobs.
	Token pulumix.Input[*string] `pulumi:"token"`
	// The cache server URL to use for artifacts.
	//
	// Defaults to `$ACTIONS_CACHE_URL`, although a separate action like
	// `crazy-max/ghaction-github-runtime` is recommended to expose this
	// environment variable to your jobs.
	Url pulumix.Input[*string] `pulumi:"url"`
}

// Defaults sets the appropriate defaults for CacheToGitHubActionsArgs
func (val *CacheToGitHubActionsArgs) Defaults() *CacheToGitHubActionsArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.IgnoreError == nil {
		tmp.IgnoreError = pulumix.Ptr(false)
	}
	if tmp.Mode == nil {
		tmp.Mode = pulumix.Ptr(CacheMode("min"))
	}
	if tmp.Scope == nil {
		if d := internal.GetEnvOrDefault("", nil, "buildkit"); d != nil {
			tmp.Scope = pulumix.Ptr(d.(string))
		}
	}
	if tmp.Token == nil {
		if d := internal.GetEnvOrDefault("", nil, "ACTIONS_RUNTIME_TOKEN"); d != nil {
			tmp.Token = pulumix.Ptr(d.(string))
		}
	}
	if tmp.Url == nil {
		if d := internal.GetEnvOrDefault("", nil, "ACTIONS_CACHE_URL"); d != nil {
			tmp.Url = pulumix.Ptr(d.(string))
		}
	}
	return &tmp
}
func (CacheToGitHubActionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CacheToGitHubActions)(nil)).Elem()
}

func (i CacheToGitHubActionsArgs) ToCacheToGitHubActionsOutput() CacheToGitHubActionsOutput {
	return i.ToCacheToGitHubActionsOutputWithContext(context.Background())
}

func (i CacheToGitHubActionsArgs) ToCacheToGitHubActionsOutputWithContext(ctx context.Context) CacheToGitHubActionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CacheToGitHubActionsOutput)
}

func (i *CacheToGitHubActionsArgs) ToOutput(ctx context.Context) pulumix.Output[*CacheToGitHubActionsArgs] {
	return pulumix.Val(i)
}

type CacheToGitHubActionsOutput struct{ *pulumi.OutputState }

func (CacheToGitHubActionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CacheToGitHubActions)(nil)).Elem()
}

func (o CacheToGitHubActionsOutput) ToCacheToGitHubActionsOutput() CacheToGitHubActionsOutput {
	return o
}

func (o CacheToGitHubActionsOutput) ToCacheToGitHubActionsOutputWithContext(ctx context.Context) CacheToGitHubActionsOutput {
	return o
}

func (o CacheToGitHubActionsOutput) ToOutput(ctx context.Context) pulumix.Output[CacheToGitHubActions] {
	return pulumix.Output[CacheToGitHubActions]{
		OutputState: o.OutputState,
	}
}

// Ignore errors caused by failed cache exports.
func (o CacheToGitHubActionsOutput) IgnoreError() pulumix.Output[*bool] {
	return pulumix.Apply[CacheToGitHubActions](o, func(v CacheToGitHubActions) *bool { return v.IgnoreError })
}

// The cache mode to use. Defaults to `min`.
func (o CacheToGitHubActionsOutput) Mode() pulumix.Output[*CacheMode] {
	return pulumix.Apply[CacheToGitHubActions](o, func(v CacheToGitHubActions) *CacheMode { return v.Mode })
}

// The scope to use for cache keys. Defaults to `buildkit`.
//
// This should be set if building and caching multiple images in one
// workflow, otherwise caches will overwrite each other.
func (o CacheToGitHubActionsOutput) Scope() pulumix.Output[*string] {
	return pulumix.Apply[CacheToGitHubActions](o, func(v CacheToGitHubActions) *string { return v.Scope })
}

// The GitHub Actions token to use. This is not a personal access tokens
// and is typically generated automatically as part of each job.
//
// Defaults to `$ACTIONS_RUNTIME_TOKEN`, although a separate action like
// `crazy-max/ghaction-github-runtime` is recommended to expose this
// environment variable to your jobs.
func (o CacheToGitHubActionsOutput) Token() pulumix.Output[*string] {
	return pulumix.Apply[CacheToGitHubActions](o, func(v CacheToGitHubActions) *string { return v.Token })
}

// The cache server URL to use for artifacts.
//
// Defaults to `$ACTIONS_CACHE_URL`, although a separate action like
// `crazy-max/ghaction-github-runtime` is recommended to expose this
// environment variable to your jobs.
func (o CacheToGitHubActionsOutput) Url() pulumix.Output[*string] {
	return pulumix.Apply[CacheToGitHubActions](o, func(v CacheToGitHubActions) *string { return v.Url })
}

// Include an inline cache with the exported image.
type CacheToInline struct {
}

// Include an inline cache with the exported image.
type CacheToInlineArgs struct {
}

func (CacheToInlineArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CacheToInline)(nil)).Elem()
}

func (i CacheToInlineArgs) ToCacheToInlineOutput() CacheToInlineOutput {
	return i.ToCacheToInlineOutputWithContext(context.Background())
}

func (i CacheToInlineArgs) ToCacheToInlineOutputWithContext(ctx context.Context) CacheToInlineOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CacheToInlineOutput)
}

func (i *CacheToInlineArgs) ToOutput(ctx context.Context) pulumix.Output[*CacheToInlineArgs] {
	return pulumix.Val(i)
}

// Include an inline cache with the exported image.
type CacheToInlineOutput struct{ *pulumi.OutputState }

func (CacheToInlineOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CacheToInline)(nil)).Elem()
}

func (o CacheToInlineOutput) ToCacheToInlineOutput() CacheToInlineOutput {
	return o
}

func (o CacheToInlineOutput) ToCacheToInlineOutputWithContext(ctx context.Context) CacheToInlineOutput {
	return o
}

func (o CacheToInlineOutput) ToOutput(ctx context.Context) pulumix.Output[CacheToInline] {
	return pulumix.Output[CacheToInline]{
		OutputState: o.OutputState,
	}
}

type CacheToLocal struct {
	// The compression type to use.
	Compression *CompressionType `pulumi:"compression"`
	// Compression level from 0 to 22.
	CompressionLevel *int `pulumi:"compressionLevel"`
	// Path of the local directory to export the cache.
	Dest string `pulumi:"dest"`
	// Forcefully apply compression.
	ForceCompression *bool `pulumi:"forceCompression"`
	// Ignore errors caused by failed cache exports.
	IgnoreError *bool `pulumi:"ignoreError"`
	// The cache mode to use. Defaults to `min`.
	Mode *CacheMode `pulumi:"mode"`
}

// Defaults sets the appropriate defaults for CacheToLocal
func (val *CacheToLocal) Defaults() *CacheToLocal {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Compression == nil {
		compression_ := CompressionType("gzip")
		tmp.Compression = &compression_
	}
	if tmp.CompressionLevel == nil {
		compressionLevel_ := 0
		tmp.CompressionLevel = &compressionLevel_
	}
	if tmp.ForceCompression == nil {
		forceCompression_ := false
		tmp.ForceCompression = &forceCompression_
	}
	if tmp.IgnoreError == nil {
		ignoreError_ := false
		tmp.IgnoreError = &ignoreError_
	}
	if tmp.Mode == nil {
		mode_ := CacheMode("min")
		tmp.Mode = &mode_
	}
	return &tmp
}

type CacheToLocalArgs struct {
	// The compression type to use.
	Compression pulumix.Input[*CompressionType] `pulumi:"compression"`
	// Compression level from 0 to 22.
	CompressionLevel pulumix.Input[*int] `pulumi:"compressionLevel"`
	// Path of the local directory to export the cache.
	Dest pulumix.Input[string] `pulumi:"dest"`
	// Forcefully apply compression.
	ForceCompression pulumix.Input[*bool] `pulumi:"forceCompression"`
	// Ignore errors caused by failed cache exports.
	IgnoreError pulumix.Input[*bool] `pulumi:"ignoreError"`
	// The cache mode to use. Defaults to `min`.
	Mode pulumix.Input[*CacheMode] `pulumi:"mode"`
}

// Defaults sets the appropriate defaults for CacheToLocalArgs
func (val *CacheToLocalArgs) Defaults() *CacheToLocalArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Compression == nil {
		tmp.Compression = pulumix.Ptr(CompressionType("gzip"))
	}
	if tmp.CompressionLevel == nil {
		tmp.CompressionLevel = pulumix.Ptr(0)
	}
	if tmp.ForceCompression == nil {
		tmp.ForceCompression = pulumix.Ptr(false)
	}
	if tmp.IgnoreError == nil {
		tmp.IgnoreError = pulumix.Ptr(false)
	}
	if tmp.Mode == nil {
		tmp.Mode = pulumix.Ptr(CacheMode("min"))
	}
	return &tmp
}
func (CacheToLocalArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CacheToLocal)(nil)).Elem()
}

func (i CacheToLocalArgs) ToCacheToLocalOutput() CacheToLocalOutput {
	return i.ToCacheToLocalOutputWithContext(context.Background())
}

func (i CacheToLocalArgs) ToCacheToLocalOutputWithContext(ctx context.Context) CacheToLocalOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CacheToLocalOutput)
}

func (i *CacheToLocalArgs) ToOutput(ctx context.Context) pulumix.Output[*CacheToLocalArgs] {
	return pulumix.Val(i)
}

type CacheToLocalOutput struct{ *pulumi.OutputState }

func (CacheToLocalOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CacheToLocal)(nil)).Elem()
}

func (o CacheToLocalOutput) ToCacheToLocalOutput() CacheToLocalOutput {
	return o
}

func (o CacheToLocalOutput) ToCacheToLocalOutputWithContext(ctx context.Context) CacheToLocalOutput {
	return o
}

func (o CacheToLocalOutput) ToOutput(ctx context.Context) pulumix.Output[CacheToLocal] {
	return pulumix.Output[CacheToLocal]{
		OutputState: o.OutputState,
	}
}

// The compression type to use.
func (o CacheToLocalOutput) Compression() pulumix.Output[*CompressionType] {
	return pulumix.Apply[CacheToLocal](o, func(v CacheToLocal) *CompressionType { return v.Compression })
}

// Compression level from 0 to 22.
func (o CacheToLocalOutput) CompressionLevel() pulumix.Output[*int] {
	return pulumix.Apply[CacheToLocal](o, func(v CacheToLocal) *int { return v.CompressionLevel })
}

// Path of the local directory to export the cache.
func (o CacheToLocalOutput) Dest() pulumix.Output[string] {
	return pulumix.Apply[CacheToLocal](o, func(v CacheToLocal) string { return v.Dest })
}

// Forcefully apply compression.
func (o CacheToLocalOutput) ForceCompression() pulumix.Output[*bool] {
	return pulumix.Apply[CacheToLocal](o, func(v CacheToLocal) *bool { return v.ForceCompression })
}

// Ignore errors caused by failed cache exports.
func (o CacheToLocalOutput) IgnoreError() pulumix.Output[*bool] {
	return pulumix.Apply[CacheToLocal](o, func(v CacheToLocal) *bool { return v.IgnoreError })
}

// The cache mode to use. Defaults to `min`.
func (o CacheToLocalOutput) Mode() pulumix.Output[*CacheMode] {
	return pulumix.Apply[CacheToLocal](o, func(v CacheToLocal) *CacheMode { return v.Mode })
}

type CacheToRegistry struct {
	// The compression type to use.
	Compression *CompressionType `pulumi:"compression"`
	// Compression level from 0 to 22.
	CompressionLevel *int `pulumi:"compressionLevel"`
	// Forcefully apply compression.
	ForceCompression *bool `pulumi:"forceCompression"`
	// Ignore errors caused by failed cache exports.
	IgnoreError *bool `pulumi:"ignoreError"`
	// Export cache manifest as an OCI-compatible image manifest instead of a
	// manifest list. Requires `ociMediaTypes` to also be `true`.
	//
	// Some registries like AWS ECR will not work with caching if this is
	// `false`.
	//
	// Defaults to `false` to match Docker's default behavior.
	ImageManifest *bool `pulumi:"imageManifest"`
	// The cache mode to use. Defaults to `min`.
	Mode *CacheMode `pulumi:"mode"`
	// Whether to use OCI media types in exported manifests. Defaults to
	// `true`.
	OciMediaTypes *bool `pulumi:"ociMediaTypes"`
	// Fully qualified name of the cache image to import.
	Ref string `pulumi:"ref"`
}

// Defaults sets the appropriate defaults for CacheToRegistry
func (val *CacheToRegistry) Defaults() *CacheToRegistry {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Compression == nil {
		compression_ := CompressionType("gzip")
		tmp.Compression = &compression_
	}
	if tmp.CompressionLevel == nil {
		compressionLevel_ := 0
		tmp.CompressionLevel = &compressionLevel_
	}
	if tmp.ForceCompression == nil {
		forceCompression_ := false
		tmp.ForceCompression = &forceCompression_
	}
	if tmp.IgnoreError == nil {
		ignoreError_ := false
		tmp.IgnoreError = &ignoreError_
	}
	if tmp.ImageManifest == nil {
		imageManifest_ := false
		tmp.ImageManifest = &imageManifest_
	}
	if tmp.Mode == nil {
		mode_ := CacheMode("min")
		tmp.Mode = &mode_
	}
	if tmp.OciMediaTypes == nil {
		ociMediaTypes_ := true
		tmp.OciMediaTypes = &ociMediaTypes_
	}
	return &tmp
}

type CacheToRegistryArgs struct {
	// The compression type to use.
	Compression pulumix.Input[*CompressionType] `pulumi:"compression"`
	// Compression level from 0 to 22.
	CompressionLevel pulumix.Input[*int] `pulumi:"compressionLevel"`
	// Forcefully apply compression.
	ForceCompression pulumix.Input[*bool] `pulumi:"forceCompression"`
	// Ignore errors caused by failed cache exports.
	IgnoreError pulumix.Input[*bool] `pulumi:"ignoreError"`
	// Export cache manifest as an OCI-compatible image manifest instead of a
	// manifest list. Requires `ociMediaTypes` to also be `true`.
	//
	// Some registries like AWS ECR will not work with caching if this is
	// `false`.
	//
	// Defaults to `false` to match Docker's default behavior.
	ImageManifest pulumix.Input[*bool] `pulumi:"imageManifest"`
	// The cache mode to use. Defaults to `min`.
	Mode pulumix.Input[*CacheMode] `pulumi:"mode"`
	// Whether to use OCI media types in exported manifests. Defaults to
	// `true`.
	OciMediaTypes pulumix.Input[*bool] `pulumi:"ociMediaTypes"`
	// Fully qualified name of the cache image to import.
	Ref pulumix.Input[string] `pulumi:"ref"`
}

// Defaults sets the appropriate defaults for CacheToRegistryArgs
func (val *CacheToRegistryArgs) Defaults() *CacheToRegistryArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Compression == nil {
		tmp.Compression = pulumix.Ptr(CompressionType("gzip"))
	}
	if tmp.CompressionLevel == nil {
		tmp.CompressionLevel = pulumix.Ptr(0)
	}
	if tmp.ForceCompression == nil {
		tmp.ForceCompression = pulumix.Ptr(false)
	}
	if tmp.IgnoreError == nil {
		tmp.IgnoreError = pulumix.Ptr(false)
	}
	if tmp.ImageManifest == nil {
		tmp.ImageManifest = pulumix.Ptr(false)
	}
	if tmp.Mode == nil {
		tmp.Mode = pulumix.Ptr(CacheMode("min"))
	}
	if tmp.OciMediaTypes == nil {
		tmp.OciMediaTypes = pulumix.Ptr(true)
	}
	return &tmp
}
func (CacheToRegistryArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CacheToRegistry)(nil)).Elem()
}

func (i CacheToRegistryArgs) ToCacheToRegistryOutput() CacheToRegistryOutput {
	return i.ToCacheToRegistryOutputWithContext(context.Background())
}

func (i CacheToRegistryArgs) ToCacheToRegistryOutputWithContext(ctx context.Context) CacheToRegistryOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CacheToRegistryOutput)
}

func (i *CacheToRegistryArgs) ToOutput(ctx context.Context) pulumix.Output[*CacheToRegistryArgs] {
	return pulumix.Val(i)
}

type CacheToRegistryOutput struct{ *pulumi.OutputState }

func (CacheToRegistryOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CacheToRegistry)(nil)).Elem()
}

func (o CacheToRegistryOutput) ToCacheToRegistryOutput() CacheToRegistryOutput {
	return o
}

func (o CacheToRegistryOutput) ToCacheToRegistryOutputWithContext(ctx context.Context) CacheToRegistryOutput {
	return o
}

func (o CacheToRegistryOutput) ToOutput(ctx context.Context) pulumix.Output[CacheToRegistry] {
	return pulumix.Output[CacheToRegistry]{
		OutputState: o.OutputState,
	}
}

// The compression type to use.
func (o CacheToRegistryOutput) Compression() pulumix.Output[*CompressionType] {
	return pulumix.Apply[CacheToRegistry](o, func(v CacheToRegistry) *CompressionType { return v.Compression })
}

// Compression level from 0 to 22.
func (o CacheToRegistryOutput) CompressionLevel() pulumix.Output[*int] {
	return pulumix.Apply[CacheToRegistry](o, func(v CacheToRegistry) *int { return v.CompressionLevel })
}

// Forcefully apply compression.
func (o CacheToRegistryOutput) ForceCompression() pulumix.Output[*bool] {
	return pulumix.Apply[CacheToRegistry](o, func(v CacheToRegistry) *bool { return v.ForceCompression })
}

// Ignore errors caused by failed cache exports.
func (o CacheToRegistryOutput) IgnoreError() pulumix.Output[*bool] {
	return pulumix.Apply[CacheToRegistry](o, func(v CacheToRegistry) *bool { return v.IgnoreError })
}

// Export cache manifest as an OCI-compatible image manifest instead of a
// manifest list. Requires `ociMediaTypes` to also be `true`.
//
// Some registries like AWS ECR will not work with caching if this is
// `false`.
//
// Defaults to `false` to match Docker's default behavior.
func (o CacheToRegistryOutput) ImageManifest() pulumix.Output[*bool] {
	return pulumix.Apply[CacheToRegistry](o, func(v CacheToRegistry) *bool { return v.ImageManifest })
}

// The cache mode to use. Defaults to `min`.
func (o CacheToRegistryOutput) Mode() pulumix.Output[*CacheMode] {
	return pulumix.Apply[CacheToRegistry](o, func(v CacheToRegistry) *CacheMode { return v.Mode })
}

// Whether to use OCI media types in exported manifests. Defaults to
// `true`.
func (o CacheToRegistryOutput) OciMediaTypes() pulumix.Output[*bool] {
	return pulumix.Apply[CacheToRegistry](o, func(v CacheToRegistry) *bool { return v.OciMediaTypes })
}

// Fully qualified name of the cache image to import.
func (o CacheToRegistryOutput) Ref() pulumix.Output[string] {
	return pulumix.Apply[CacheToRegistry](o, func(v CacheToRegistry) string { return v.Ref })
}

type CacheToS3 struct {
	// Defaults to `$AWS_ACCESS_KEY_ID`.
	AccessKeyId *string `pulumi:"accessKeyId"`
	// Prefix to prepend to blob filenames.
	BlobsPrefix *string `pulumi:"blobsPrefix"`
	// Name of the S3 bucket.
	Bucket string `pulumi:"bucket"`
	// Endpoint of the S3 bucket.
	EndpointUrl *string `pulumi:"endpointUrl"`
	// Ignore errors caused by failed cache exports.
	IgnoreError *bool `pulumi:"ignoreError"`
	// Prefix to prepend on manifest filenames.
	ManifestsPrefix *string `pulumi:"manifestsPrefix"`
	// The cache mode to use. Defaults to `min`.
	Mode *CacheMode `pulumi:"mode"`
	// Name of the cache image.
	Name *string `pulumi:"name"`
	// The geographic location of the bucket. Defaults to `$AWS_REGION`.
	Region string `pulumi:"region"`
	// Defaults to `$AWS_SECRET_ACCESS_KEY`.
	SecretAccessKey *string `pulumi:"secretAccessKey"`
	// Defaults to `$AWS_SESSION_TOKEN`.
	SessionToken *string `pulumi:"sessionToken"`
	// Uses `bucket` in the URL instead of hostname when `true`.
	UsePathStyle *bool `pulumi:"usePathStyle"`
}

// Defaults sets the appropriate defaults for CacheToS3
func (val *CacheToS3) Defaults() *CacheToS3 {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.AccessKeyId == nil {
		if d := internal.GetEnvOrDefault("", nil, "AWS_ACCESS_KEY_ID"); d != nil {
			accessKeyId_ := d.(string)
			tmp.AccessKeyId = &accessKeyId_
		}
	}
	if tmp.IgnoreError == nil {
		ignoreError_ := false
		tmp.IgnoreError = &ignoreError_
	}
	if tmp.Mode == nil {
		mode_ := CacheMode("min")
		tmp.Mode = &mode_
	}
	if internal.IsZero(tmp.Region) {
		if d := internal.GetEnvOrDefault("", nil, "AWS_REGION"); d != nil {
			tmp.Region = d.(string)
		}
	}
	if tmp.SecretAccessKey == nil {
		if d := internal.GetEnvOrDefault("", nil, "AWS_SECRET_ACCESS_KEY"); d != nil {
			secretAccessKey_ := d.(string)
			tmp.SecretAccessKey = &secretAccessKey_
		}
	}
	if tmp.SessionToken == nil {
		if d := internal.GetEnvOrDefault("", nil, "AWS_SESSION_TOKEN"); d != nil {
			sessionToken_ := d.(string)
			tmp.SessionToken = &sessionToken_
		}
	}
	return &tmp
}

type CacheToS3Args struct {
	// Defaults to `$AWS_ACCESS_KEY_ID`.
	AccessKeyId pulumix.Input[*string] `pulumi:"accessKeyId"`
	// Prefix to prepend to blob filenames.
	BlobsPrefix pulumix.Input[*string] `pulumi:"blobsPrefix"`
	// Name of the S3 bucket.
	Bucket pulumix.Input[string] `pulumi:"bucket"`
	// Endpoint of the S3 bucket.
	EndpointUrl pulumix.Input[*string] `pulumi:"endpointUrl"`
	// Ignore errors caused by failed cache exports.
	IgnoreError pulumix.Input[*bool] `pulumi:"ignoreError"`
	// Prefix to prepend on manifest filenames.
	ManifestsPrefix pulumix.Input[*string] `pulumi:"manifestsPrefix"`
	// The cache mode to use. Defaults to `min`.
	Mode pulumix.Input[*CacheMode] `pulumi:"mode"`
	// Name of the cache image.
	Name pulumix.Input[*string] `pulumi:"name"`
	// The geographic location of the bucket. Defaults to `$AWS_REGION`.
	Region pulumix.Input[string] `pulumi:"region"`
	// Defaults to `$AWS_SECRET_ACCESS_KEY`.
	SecretAccessKey pulumix.Input[*string] `pulumi:"secretAccessKey"`
	// Defaults to `$AWS_SESSION_TOKEN`.
	SessionToken pulumix.Input[*string] `pulumi:"sessionToken"`
	// Uses `bucket` in the URL instead of hostname when `true`.
	UsePathStyle pulumix.Input[*bool] `pulumi:"usePathStyle"`
}

// Defaults sets the appropriate defaults for CacheToS3Args
func (val *CacheToS3Args) Defaults() *CacheToS3Args {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.AccessKeyId == nil {
		if d := internal.GetEnvOrDefault("", nil, "AWS_ACCESS_KEY_ID"); d != nil {
			tmp.AccessKeyId = pulumix.Ptr(d.(string))
		}
	}
	if tmp.IgnoreError == nil {
		tmp.IgnoreError = pulumix.Ptr(false)
	}
	if tmp.Mode == nil {
		tmp.Mode = pulumix.Ptr(CacheMode("min"))
	}
	if tmp.Region == nil {
		if d := internal.GetEnvOrDefault("", nil, "AWS_REGION"); d != nil {
			tmp.Region = pulumix.Val(d.(string))
		}
	}
	if tmp.SecretAccessKey == nil {
		if d := internal.GetEnvOrDefault("", nil, "AWS_SECRET_ACCESS_KEY"); d != nil {
			tmp.SecretAccessKey = pulumix.Ptr(d.(string))
		}
	}
	if tmp.SessionToken == nil {
		if d := internal.GetEnvOrDefault("", nil, "AWS_SESSION_TOKEN"); d != nil {
			tmp.SessionToken = pulumix.Ptr(d.(string))
		}
	}
	return &tmp
}
func (CacheToS3Args) ElementType() reflect.Type {
	return reflect.TypeOf((*CacheToS3)(nil)).Elem()
}

func (i CacheToS3Args) ToCacheToS3Output() CacheToS3Output {
	return i.ToCacheToS3OutputWithContext(context.Background())
}

func (i CacheToS3Args) ToCacheToS3OutputWithContext(ctx context.Context) CacheToS3Output {
	return pulumi.ToOutputWithContext(ctx, i).(CacheToS3Output)
}

func (i *CacheToS3Args) ToOutput(ctx context.Context) pulumix.Output[*CacheToS3Args] {
	return pulumix.Val(i)
}

type CacheToS3Output struct{ *pulumi.OutputState }

func (CacheToS3Output) ElementType() reflect.Type {
	return reflect.TypeOf((*CacheToS3)(nil)).Elem()
}

func (o CacheToS3Output) ToCacheToS3Output() CacheToS3Output {
	return o
}

func (o CacheToS3Output) ToCacheToS3OutputWithContext(ctx context.Context) CacheToS3Output {
	return o
}

func (o CacheToS3Output) ToOutput(ctx context.Context) pulumix.Output[CacheToS3] {
	return pulumix.Output[CacheToS3]{
		OutputState: o.OutputState,
	}
}

// Defaults to `$AWS_ACCESS_KEY_ID`.
func (o CacheToS3Output) AccessKeyId() pulumix.Output[*string] {
	return pulumix.Apply[CacheToS3](o, func(v CacheToS3) *string { return v.AccessKeyId })
}

// Prefix to prepend to blob filenames.
func (o CacheToS3Output) BlobsPrefix() pulumix.Output[*string] {
	return pulumix.Apply[CacheToS3](o, func(v CacheToS3) *string { return v.BlobsPrefix })
}

// Name of the S3 bucket.
func (o CacheToS3Output) Bucket() pulumix.Output[string] {
	return pulumix.Apply[CacheToS3](o, func(v CacheToS3) string { return v.Bucket })
}

// Endpoint of the S3 bucket.
func (o CacheToS3Output) EndpointUrl() pulumix.Output[*string] {
	return pulumix.Apply[CacheToS3](o, func(v CacheToS3) *string { return v.EndpointUrl })
}

// Ignore errors caused by failed cache exports.
func (o CacheToS3Output) IgnoreError() pulumix.Output[*bool] {
	return pulumix.Apply[CacheToS3](o, func(v CacheToS3) *bool { return v.IgnoreError })
}

// Prefix to prepend on manifest filenames.
func (o CacheToS3Output) ManifestsPrefix() pulumix.Output[*string] {
	return pulumix.Apply[CacheToS3](o, func(v CacheToS3) *string { return v.ManifestsPrefix })
}

// The cache mode to use. Defaults to `min`.
func (o CacheToS3Output) Mode() pulumix.Output[*CacheMode] {
	return pulumix.Apply[CacheToS3](o, func(v CacheToS3) *CacheMode { return v.Mode })
}

// Name of the cache image.
func (o CacheToS3Output) Name() pulumix.Output[*string] {
	return pulumix.Apply[CacheToS3](o, func(v CacheToS3) *string { return v.Name })
}

// The geographic location of the bucket. Defaults to `$AWS_REGION`.
func (o CacheToS3Output) Region() pulumix.Output[string] {
	return pulumix.Apply[CacheToS3](o, func(v CacheToS3) string { return v.Region })
}

// Defaults to `$AWS_SECRET_ACCESS_KEY`.
func (o CacheToS3Output) SecretAccessKey() pulumix.Output[*string] {
	return pulumix.Apply[CacheToS3](o, func(v CacheToS3) *string { return v.SecretAccessKey })
}

// Defaults to `$AWS_SESSION_TOKEN`.
func (o CacheToS3Output) SessionToken() pulumix.Output[*string] {
	return pulumix.Apply[CacheToS3](o, func(v CacheToS3) *string { return v.SessionToken })
}

// Uses `bucket` in the URL instead of hostname when `true`.
func (o CacheToS3Output) UsePathStyle() pulumix.Output[*bool] {
	return pulumix.Apply[CacheToS3](o, func(v CacheToS3) *bool { return v.UsePathStyle })
}

type Context struct {
	// Resources to use for build context.
	//
	// The location can be:
	// * A relative or absolute path to a local directory (`.`, `./app`,
	//   `/app`, etc.).
	// * A remote URL of a Git repository, tarball, or plain text file
	//   (`https://github.com/user/myrepo.git`, `http://server/context.tar.gz`,
	//   etc.).
	Location string `pulumi:"location"`
}

type ContextArgs struct {
	// Resources to use for build context.
	//
	// The location can be:
	// * A relative or absolute path to a local directory (`.`, `./app`,
	//   `/app`, etc.).
	// * A remote URL of a Git repository, tarball, or plain text file
	//   (`https://github.com/user/myrepo.git`, `http://server/context.tar.gz`,
	//   etc.).
	Location pulumix.Input[string] `pulumi:"location"`
}

func (ContextArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Context)(nil)).Elem()
}

func (i ContextArgs) ToContextOutput() ContextOutput {
	return i.ToContextOutputWithContext(context.Background())
}

func (i ContextArgs) ToContextOutputWithContext(ctx context.Context) ContextOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContextOutput)
}

func (i *ContextArgs) ToOutput(ctx context.Context) pulumix.Output[*ContextArgs] {
	return pulumix.Val(i)
}

type ContextOutput struct{ *pulumi.OutputState }

func (ContextOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Context)(nil)).Elem()
}

func (o ContextOutput) ToContextOutput() ContextOutput {
	return o
}

func (o ContextOutput) ToContextOutputWithContext(ctx context.Context) ContextOutput {
	return o
}

func (o ContextOutput) ToOutput(ctx context.Context) pulumix.Output[Context] {
	return pulumix.Output[Context]{
		OutputState: o.OutputState,
	}
}

// Resources to use for build context.
//
// The location can be:
//   - A relative or absolute path to a local directory (`.`, `./app`,
//     `/app`, etc.).
//   - A remote URL of a Git repository, tarball, or plain text file
//     (`https://github.com/user/myrepo.git`, `http://server/context.tar.gz`,
//     etc.).
func (o ContextOutput) Location() pulumix.Output[string] {
	return pulumix.Apply[Context](o, func(v Context) string { return v.Location })
}

type Dockerfile struct {
	// Raw Dockerfile contents.
	//
	// Conflicts with `location`.
	//
	// Equivalent to invoking Docker with `-f -`.
	Inline *string `pulumi:"inline"`
	// Location of the Dockerfile to use.
	//
	// Can be a relative or absolute path to a local file, or a remote URL.
	//
	// Defaults to `${context.location}/Dockerfile` if context is on-disk.
	//
	// Conflicts with `inline`.
	Location *string `pulumi:"location"`
}

type DockerfileArgs struct {
	// Raw Dockerfile contents.
	//
	// Conflicts with `location`.
	//
	// Equivalent to invoking Docker with `-f -`.
	Inline pulumix.Input[*string] `pulumi:"inline"`
	// Location of the Dockerfile to use.
	//
	// Can be a relative or absolute path to a local file, or a remote URL.
	//
	// Defaults to `${context.location}/Dockerfile` if context is on-disk.
	//
	// Conflicts with `inline`.
	Location pulumix.Input[*string] `pulumi:"location"`
}

func (DockerfileArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Dockerfile)(nil)).Elem()
}

func (i DockerfileArgs) ToDockerfileOutput() DockerfileOutput {
	return i.ToDockerfileOutputWithContext(context.Background())
}

func (i DockerfileArgs) ToDockerfileOutputWithContext(ctx context.Context) DockerfileOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DockerfileOutput)
}

func (i *DockerfileArgs) ToOutput(ctx context.Context) pulumix.Output[*DockerfileArgs] {
	return pulumix.Val(i)
}

type DockerfileOutput struct{ *pulumi.OutputState }

func (DockerfileOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Dockerfile)(nil)).Elem()
}

func (o DockerfileOutput) ToDockerfileOutput() DockerfileOutput {
	return o
}

func (o DockerfileOutput) ToDockerfileOutputWithContext(ctx context.Context) DockerfileOutput {
	return o
}

func (o DockerfileOutput) ToOutput(ctx context.Context) pulumix.Output[Dockerfile] {
	return pulumix.Output[Dockerfile]{
		OutputState: o.OutputState,
	}
}

// Raw Dockerfile contents.
//
// Conflicts with `location`.
//
// Equivalent to invoking Docker with `-f -`.
func (o DockerfileOutput) Inline() pulumix.Output[*string] {
	return pulumix.Apply[Dockerfile](o, func(v Dockerfile) *string { return v.Inline })
}

// Location of the Dockerfile to use.
//
// Can be a relative or absolute path to a local file, or a remote URL.
//
// Defaults to `${context.location}/Dockerfile` if context is on-disk.
//
// Conflicts with `inline`.
func (o DockerfileOutput) Location() pulumix.Output[*string] {
	return pulumix.Apply[Dockerfile](o, func(v Dockerfile) *string { return v.Location })
}

type Export struct {
	// A no-op export. Helpful for silencing the 'no exports' warning if you
	// just want to populate caches.
	Cacheonly *ExportCacheOnly `pulumi:"cacheonly"`
	// When `true` this entry will be excluded. Defaults to `false`.
	Disabled *bool `pulumi:"disabled"`
	// Export as a Docker image layout.
	Docker *ExportDocker `pulumi:"docker"`
	// Outputs the build result into a container image format.
	Image *ExportImage `pulumi:"image"`
	// Export to a local directory as files and directories.
	Local *ExportLocal `pulumi:"local"`
	// Identical to the Docker exporter but uses OCI media types by default.
	Oci *ExportOCI `pulumi:"oci"`
	// A raw string as you would provide it to the Docker CLI (e.g.,
	// `type=docker`)
	Raw *string `pulumi:"raw"`
	// Identical to the Image exporter, but pushes by default.
	Registry *ExportRegistry `pulumi:"registry"`
	// Export to a local directory as a tarball.
	Tar *ExportTar `pulumi:"tar"`
}

// Defaults sets the appropriate defaults for Export
func (val *Export) Defaults() *Export {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.Docker = tmp.Docker.Defaults()

	tmp.Image = tmp.Image.Defaults()

	tmp.Oci = tmp.Oci.Defaults()

	tmp.Registry = tmp.Registry.Defaults()

	return &tmp
}

type ExportArgs struct {
	// A no-op export. Helpful for silencing the 'no exports' warning if you
	// just want to populate caches.
	Cacheonly pulumix.Input[*ExportCacheOnlyArgs] `pulumi:"cacheonly"`
	// When `true` this entry will be excluded. Defaults to `false`.
	Disabled pulumix.Input[*bool] `pulumi:"disabled"`
	// Export as a Docker image layout.
	Docker pulumix.Input[*ExportDockerArgs] `pulumi:"docker"`
	// Outputs the build result into a container image format.
	Image pulumix.Input[*ExportImageArgs] `pulumi:"image"`
	// Export to a local directory as files and directories.
	Local pulumix.Input[*ExportLocalArgs] `pulumi:"local"`
	// Identical to the Docker exporter but uses OCI media types by default.
	Oci pulumix.Input[*ExportOCIArgs] `pulumi:"oci"`
	// A raw string as you would provide it to the Docker CLI (e.g.,
	// `type=docker`)
	Raw pulumix.Input[*string] `pulumi:"raw"`
	// Identical to the Image exporter, but pushes by default.
	Registry pulumix.Input[*ExportRegistryArgs] `pulumi:"registry"`
	// Export to a local directory as a tarball.
	Tar pulumix.Input[*ExportTarArgs] `pulumi:"tar"`
}

// Defaults sets the appropriate defaults for ExportArgs
func (val *ExportArgs) Defaults() *ExportArgs {
	if val == nil {
		return nil
	}
	tmp := *val

	return &tmp
}
func (ExportArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Export)(nil)).Elem()
}

func (i ExportArgs) ToExportOutput() ExportOutput {
	return i.ToExportOutputWithContext(context.Background())
}

func (i ExportArgs) ToExportOutputWithContext(ctx context.Context) ExportOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExportOutput)
}

func (i *ExportArgs) ToOutput(ctx context.Context) pulumix.Output[*ExportArgs] {
	return pulumix.Val(i)
}

type ExportOutput struct{ *pulumi.OutputState }

func (ExportOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Export)(nil)).Elem()
}

func (o ExportOutput) ToExportOutput() ExportOutput {
	return o
}

func (o ExportOutput) ToExportOutputWithContext(ctx context.Context) ExportOutput {
	return o
}

func (o ExportOutput) ToOutput(ctx context.Context) pulumix.Output[Export] {
	return pulumix.Output[Export]{
		OutputState: o.OutputState,
	}
}

// A no-op export. Helpful for silencing the 'no exports' warning if you
// just want to populate caches.
func (o ExportOutput) Cacheonly() pulumix.GPtrOutput[ExportCacheOnly, ExportCacheOnlyOutput] {
	value := pulumix.Apply[Export](o, func(v Export) *ExportCacheOnly { return v.Cacheonly })
	return pulumix.GPtrOutput[ExportCacheOnly, ExportCacheOnlyOutput]{OutputState: value.OutputState}
}

// When `true` this entry will be excluded. Defaults to `false`.
func (o ExportOutput) Disabled() pulumix.Output[*bool] {
	return pulumix.Apply[Export](o, func(v Export) *bool { return v.Disabled })
}

// Export as a Docker image layout.
func (o ExportOutput) Docker() pulumix.GPtrOutput[ExportDocker, ExportDockerOutput] {
	value := pulumix.Apply[Export](o, func(v Export) *ExportDocker { return v.Docker })
	return pulumix.GPtrOutput[ExportDocker, ExportDockerOutput]{OutputState: value.OutputState}
}

// Outputs the build result into a container image format.
func (o ExportOutput) Image() pulumix.GPtrOutput[ExportImage, ExportImageOutput] {
	value := pulumix.Apply[Export](o, func(v Export) *ExportImage { return v.Image })
	return pulumix.GPtrOutput[ExportImage, ExportImageOutput]{OutputState: value.OutputState}
}

// Export to a local directory as files and directories.
func (o ExportOutput) Local() pulumix.GPtrOutput[ExportLocal, ExportLocalOutput] {
	value := pulumix.Apply[Export](o, func(v Export) *ExportLocal { return v.Local })
	return pulumix.GPtrOutput[ExportLocal, ExportLocalOutput]{OutputState: value.OutputState}
}

// Identical to the Docker exporter but uses OCI media types by default.
func (o ExportOutput) Oci() pulumix.GPtrOutput[ExportOCI, ExportOCIOutput] {
	value := pulumix.Apply[Export](o, func(v Export) *ExportOCI { return v.Oci })
	return pulumix.GPtrOutput[ExportOCI, ExportOCIOutput]{OutputState: value.OutputState}
}

// A raw string as you would provide it to the Docker CLI (e.g.,
// `type=docker`)
func (o ExportOutput) Raw() pulumix.Output[*string] {
	return pulumix.Apply[Export](o, func(v Export) *string { return v.Raw })
}

// Identical to the Image exporter, but pushes by default.
func (o ExportOutput) Registry() pulumix.GPtrOutput[ExportRegistry, ExportRegistryOutput] {
	value := pulumix.Apply[Export](o, func(v Export) *ExportRegistry { return v.Registry })
	return pulumix.GPtrOutput[ExportRegistry, ExportRegistryOutput]{OutputState: value.OutputState}
}

// Export to a local directory as a tarball.
func (o ExportOutput) Tar() pulumix.GPtrOutput[ExportTar, ExportTarOutput] {
	value := pulumix.Apply[Export](o, func(v Export) *ExportTar { return v.Tar })
	return pulumix.GPtrOutput[ExportTar, ExportTarOutput]{OutputState: value.OutputState}
}

type ExportCacheOnly struct {
}

type ExportCacheOnlyArgs struct {
}

func (ExportCacheOnlyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ExportCacheOnly)(nil)).Elem()
}

func (i ExportCacheOnlyArgs) ToExportCacheOnlyOutput() ExportCacheOnlyOutput {
	return i.ToExportCacheOnlyOutputWithContext(context.Background())
}

func (i ExportCacheOnlyArgs) ToExportCacheOnlyOutputWithContext(ctx context.Context) ExportCacheOnlyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExportCacheOnlyOutput)
}

func (i *ExportCacheOnlyArgs) ToOutput(ctx context.Context) pulumix.Output[*ExportCacheOnlyArgs] {
	return pulumix.Val(i)
}

type ExportCacheOnlyOutput struct{ *pulumi.OutputState }

func (ExportCacheOnlyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ExportCacheOnly)(nil)).Elem()
}

func (o ExportCacheOnlyOutput) ToExportCacheOnlyOutput() ExportCacheOnlyOutput {
	return o
}

func (o ExportCacheOnlyOutput) ToExportCacheOnlyOutputWithContext(ctx context.Context) ExportCacheOnlyOutput {
	return o
}

func (o ExportCacheOnlyOutput) ToOutput(ctx context.Context) pulumix.Output[ExportCacheOnly] {
	return pulumix.Output[ExportCacheOnly]{
		OutputState: o.OutputState,
	}
}

type ExportDocker struct {
	// Attach an arbitrary key/value annotation to the image.
	Annotations map[string]string `pulumi:"annotations"`
	// The compression type to use.
	Compression *CompressionType `pulumi:"compression"`
	// Compression level from 0 to 22.
	CompressionLevel *int `pulumi:"compressionLevel"`
	// The local export path.
	Dest *string `pulumi:"dest"`
	// Forcefully apply compression.
	ForceCompression *bool `pulumi:"forceCompression"`
	// Specify images names to export. This is overridden if tags are already specified.
	Names []string `pulumi:"names"`
	// Use OCI media types in exporter manifests.
	OciMediaTypes *bool `pulumi:"ociMediaTypes"`
	// Bundle the output into a tarball layout.
	Tar *bool `pulumi:"tar"`
}

// Defaults sets the appropriate defaults for ExportDocker
func (val *ExportDocker) Defaults() *ExportDocker {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Compression == nil {
		compression_ := CompressionType("gzip")
		tmp.Compression = &compression_
	}
	if tmp.CompressionLevel == nil {
		compressionLevel_ := 0
		tmp.CompressionLevel = &compressionLevel_
	}
	if tmp.ForceCompression == nil {
		forceCompression_ := false
		tmp.ForceCompression = &forceCompression_
	}
	if tmp.OciMediaTypes == nil {
		ociMediaTypes_ := false
		tmp.OciMediaTypes = &ociMediaTypes_
	}
	if tmp.Tar == nil {
		tar_ := true
		tmp.Tar = &tar_
	}
	return &tmp
}

type ExportDockerArgs struct {
	// Attach an arbitrary key/value annotation to the image.
	Annotations pulumix.Input[map[string]string] `pulumi:"annotations"`
	// The compression type to use.
	Compression pulumix.Input[*CompressionType] `pulumi:"compression"`
	// Compression level from 0 to 22.
	CompressionLevel pulumix.Input[*int] `pulumi:"compressionLevel"`
	// The local export path.
	Dest pulumix.Input[*string] `pulumi:"dest"`
	// Forcefully apply compression.
	ForceCompression pulumix.Input[*bool] `pulumi:"forceCompression"`
	// Specify images names to export. This is overridden if tags are already specified.
	Names pulumix.Input[[]string] `pulumi:"names"`
	// Use OCI media types in exporter manifests.
	OciMediaTypes pulumix.Input[*bool] `pulumi:"ociMediaTypes"`
	// Bundle the output into a tarball layout.
	Tar pulumix.Input[*bool] `pulumi:"tar"`
}

// Defaults sets the appropriate defaults for ExportDockerArgs
func (val *ExportDockerArgs) Defaults() *ExportDockerArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Compression == nil {
		tmp.Compression = pulumix.Ptr(CompressionType("gzip"))
	}
	if tmp.CompressionLevel == nil {
		tmp.CompressionLevel = pulumix.Ptr(0)
	}
	if tmp.ForceCompression == nil {
		tmp.ForceCompression = pulumix.Ptr(false)
	}
	if tmp.OciMediaTypes == nil {
		tmp.OciMediaTypes = pulumix.Ptr(false)
	}
	if tmp.Tar == nil {
		tmp.Tar = pulumix.Ptr(true)
	}
	return &tmp
}
func (ExportDockerArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ExportDocker)(nil)).Elem()
}

func (i ExportDockerArgs) ToExportDockerOutput() ExportDockerOutput {
	return i.ToExportDockerOutputWithContext(context.Background())
}

func (i ExportDockerArgs) ToExportDockerOutputWithContext(ctx context.Context) ExportDockerOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExportDockerOutput)
}

func (i *ExportDockerArgs) ToOutput(ctx context.Context) pulumix.Output[*ExportDockerArgs] {
	return pulumix.Val(i)
}

type ExportDockerOutput struct{ *pulumi.OutputState }

func (ExportDockerOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ExportDocker)(nil)).Elem()
}

func (o ExportDockerOutput) ToExportDockerOutput() ExportDockerOutput {
	return o
}

func (o ExportDockerOutput) ToExportDockerOutputWithContext(ctx context.Context) ExportDockerOutput {
	return o
}

func (o ExportDockerOutput) ToOutput(ctx context.Context) pulumix.Output[ExportDocker] {
	return pulumix.Output[ExportDocker]{
		OutputState: o.OutputState,
	}
}

// Attach an arbitrary key/value annotation to the image.
func (o ExportDockerOutput) Annotations() pulumix.MapOutput[string] {
	value := pulumix.Apply[ExportDocker](o, func(v ExportDocker) map[string]string { return v.Annotations })
	return pulumix.MapOutput[string]{OutputState: value.OutputState}
}

// The compression type to use.
func (o ExportDockerOutput) Compression() pulumix.Output[*CompressionType] {
	return pulumix.Apply[ExportDocker](o, func(v ExportDocker) *CompressionType { return v.Compression })
}

// Compression level from 0 to 22.
func (o ExportDockerOutput) CompressionLevel() pulumix.Output[*int] {
	return pulumix.Apply[ExportDocker](o, func(v ExportDocker) *int { return v.CompressionLevel })
}

// The local export path.
func (o ExportDockerOutput) Dest() pulumix.Output[*string] {
	return pulumix.Apply[ExportDocker](o, func(v ExportDocker) *string { return v.Dest })
}

// Forcefully apply compression.
func (o ExportDockerOutput) ForceCompression() pulumix.Output[*bool] {
	return pulumix.Apply[ExportDocker](o, func(v ExportDocker) *bool { return v.ForceCompression })
}

// Specify images names to export. This is overridden if tags are already specified.
func (o ExportDockerOutput) Names() pulumix.ArrayOutput[string] {
	value := pulumix.Apply[ExportDocker](o, func(v ExportDocker) []string { return v.Names })
	return pulumix.ArrayOutput[string]{OutputState: value.OutputState}
}

// Use OCI media types in exporter manifests.
func (o ExportDockerOutput) OciMediaTypes() pulumix.Output[*bool] {
	return pulumix.Apply[ExportDocker](o, func(v ExportDocker) *bool { return v.OciMediaTypes })
}

// Bundle the output into a tarball layout.
func (o ExportDockerOutput) Tar() pulumix.Output[*bool] {
	return pulumix.Apply[ExportDocker](o, func(v ExportDocker) *bool { return v.Tar })
}

type ExportImage struct {
	// Attach an arbitrary key/value annotation to the image.
	Annotations map[string]string `pulumi:"annotations"`
	// The compression type to use.
	Compression *CompressionType `pulumi:"compression"`
	// Compression level from 0 to 22.
	CompressionLevel *int `pulumi:"compressionLevel"`
	// Name image with `prefix@<digest>`, used for anonymous images.
	DanglingNamePrefix *string `pulumi:"danglingNamePrefix"`
	// Forcefully apply compression.
	ForceCompression *bool `pulumi:"forceCompression"`
	// Allow pushing to an insecure registry.
	Insecure *bool `pulumi:"insecure"`
	// Add additional canonical name (`name@<digest>`).
	NameCanonical *bool `pulumi:"nameCanonical"`
	// Specify images names to export. This is overridden if tags are already specified.
	Names []string `pulumi:"names"`
	// Use OCI media types in exporter manifests.
	OciMediaTypes *bool `pulumi:"ociMediaTypes"`
	// Push after creating the image. Defaults to `false`.
	Push *bool `pulumi:"push"`
	// Push image without name.
	PushByDigest *bool `pulumi:"pushByDigest"`
	// Store resulting images to the worker's image store and ensure all of
	// its blobs are in the content store.
	//
	// Defaults to `true`.
	//
	// Ignored if the worker doesn't have image store (when using OCI workers,
	// for example).
	Store *bool `pulumi:"store"`
	// Unpack image after creation (for use with containerd). Defaults to
	// `false`.
	Unpack *bool `pulumi:"unpack"`
}

// Defaults sets the appropriate defaults for ExportImage
func (val *ExportImage) Defaults() *ExportImage {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Compression == nil {
		compression_ := CompressionType("gzip")
		tmp.Compression = &compression_
	}
	if tmp.CompressionLevel == nil {
		compressionLevel_ := 0
		tmp.CompressionLevel = &compressionLevel_
	}
	if tmp.ForceCompression == nil {
		forceCompression_ := false
		tmp.ForceCompression = &forceCompression_
	}
	if tmp.OciMediaTypes == nil {
		ociMediaTypes_ := false
		tmp.OciMediaTypes = &ociMediaTypes_
	}
	if tmp.Store == nil {
		store_ := true
		tmp.Store = &store_
	}
	return &tmp
}

type ExportImageArgs struct {
	// Attach an arbitrary key/value annotation to the image.
	Annotations pulumix.Input[map[string]string] `pulumi:"annotations"`
	// The compression type to use.
	Compression pulumix.Input[*CompressionType] `pulumi:"compression"`
	// Compression level from 0 to 22.
	CompressionLevel pulumix.Input[*int] `pulumi:"compressionLevel"`
	// Name image with `prefix@<digest>`, used for anonymous images.
	DanglingNamePrefix pulumix.Input[*string] `pulumi:"danglingNamePrefix"`
	// Forcefully apply compression.
	ForceCompression pulumix.Input[*bool] `pulumi:"forceCompression"`
	// Allow pushing to an insecure registry.
	Insecure pulumix.Input[*bool] `pulumi:"insecure"`
	// Add additional canonical name (`name@<digest>`).
	NameCanonical pulumix.Input[*bool] `pulumi:"nameCanonical"`
	// Specify images names to export. This is overridden if tags are already specified.
	Names pulumix.Input[[]string] `pulumi:"names"`
	// Use OCI media types in exporter manifests.
	OciMediaTypes pulumix.Input[*bool] `pulumi:"ociMediaTypes"`
	// Push after creating the image. Defaults to `false`.
	Push pulumix.Input[*bool] `pulumi:"push"`
	// Push image without name.
	PushByDigest pulumix.Input[*bool] `pulumi:"pushByDigest"`
	// Store resulting images to the worker's image store and ensure all of
	// its blobs are in the content store.
	//
	// Defaults to `true`.
	//
	// Ignored if the worker doesn't have image store (when using OCI workers,
	// for example).
	Store pulumix.Input[*bool] `pulumi:"store"`
	// Unpack image after creation (for use with containerd). Defaults to
	// `false`.
	Unpack pulumix.Input[*bool] `pulumi:"unpack"`
}

// Defaults sets the appropriate defaults for ExportImageArgs
func (val *ExportImageArgs) Defaults() *ExportImageArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Compression == nil {
		tmp.Compression = pulumix.Ptr(CompressionType("gzip"))
	}
	if tmp.CompressionLevel == nil {
		tmp.CompressionLevel = pulumix.Ptr(0)
	}
	if tmp.ForceCompression == nil {
		tmp.ForceCompression = pulumix.Ptr(false)
	}
	if tmp.OciMediaTypes == nil {
		tmp.OciMediaTypes = pulumix.Ptr(false)
	}
	if tmp.Store == nil {
		tmp.Store = pulumix.Ptr(true)
	}
	return &tmp
}
func (ExportImageArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ExportImage)(nil)).Elem()
}

func (i ExportImageArgs) ToExportImageOutput() ExportImageOutput {
	return i.ToExportImageOutputWithContext(context.Background())
}

func (i ExportImageArgs) ToExportImageOutputWithContext(ctx context.Context) ExportImageOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExportImageOutput)
}

func (i *ExportImageArgs) ToOutput(ctx context.Context) pulumix.Output[*ExportImageArgs] {
	return pulumix.Val(i)
}

type ExportImageOutput struct{ *pulumi.OutputState }

func (ExportImageOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ExportImage)(nil)).Elem()
}

func (o ExportImageOutput) ToExportImageOutput() ExportImageOutput {
	return o
}

func (o ExportImageOutput) ToExportImageOutputWithContext(ctx context.Context) ExportImageOutput {
	return o
}

func (o ExportImageOutput) ToOutput(ctx context.Context) pulumix.Output[ExportImage] {
	return pulumix.Output[ExportImage]{
		OutputState: o.OutputState,
	}
}

// Attach an arbitrary key/value annotation to the image.
func (o ExportImageOutput) Annotations() pulumix.MapOutput[string] {
	value := pulumix.Apply[ExportImage](o, func(v ExportImage) map[string]string { return v.Annotations })
	return pulumix.MapOutput[string]{OutputState: value.OutputState}
}

// The compression type to use.
func (o ExportImageOutput) Compression() pulumix.Output[*CompressionType] {
	return pulumix.Apply[ExportImage](o, func(v ExportImage) *CompressionType { return v.Compression })
}

// Compression level from 0 to 22.
func (o ExportImageOutput) CompressionLevel() pulumix.Output[*int] {
	return pulumix.Apply[ExportImage](o, func(v ExportImage) *int { return v.CompressionLevel })
}

// Name image with `prefix@<digest>`, used for anonymous images.
func (o ExportImageOutput) DanglingNamePrefix() pulumix.Output[*string] {
	return pulumix.Apply[ExportImage](o, func(v ExportImage) *string { return v.DanglingNamePrefix })
}

// Forcefully apply compression.
func (o ExportImageOutput) ForceCompression() pulumix.Output[*bool] {
	return pulumix.Apply[ExportImage](o, func(v ExportImage) *bool { return v.ForceCompression })
}

// Allow pushing to an insecure registry.
func (o ExportImageOutput) Insecure() pulumix.Output[*bool] {
	return pulumix.Apply[ExportImage](o, func(v ExportImage) *bool { return v.Insecure })
}

// Add additional canonical name (`name@<digest>`).
func (o ExportImageOutput) NameCanonical() pulumix.Output[*bool] {
	return pulumix.Apply[ExportImage](o, func(v ExportImage) *bool { return v.NameCanonical })
}

// Specify images names to export. This is overridden if tags are already specified.
func (o ExportImageOutput) Names() pulumix.ArrayOutput[string] {
	value := pulumix.Apply[ExportImage](o, func(v ExportImage) []string { return v.Names })
	return pulumix.ArrayOutput[string]{OutputState: value.OutputState}
}

// Use OCI media types in exporter manifests.
func (o ExportImageOutput) OciMediaTypes() pulumix.Output[*bool] {
	return pulumix.Apply[ExportImage](o, func(v ExportImage) *bool { return v.OciMediaTypes })
}

// Push after creating the image. Defaults to `false`.
func (o ExportImageOutput) Push() pulumix.Output[*bool] {
	return pulumix.Apply[ExportImage](o, func(v ExportImage) *bool { return v.Push })
}

// Push image without name.
func (o ExportImageOutput) PushByDigest() pulumix.Output[*bool] {
	return pulumix.Apply[ExportImage](o, func(v ExportImage) *bool { return v.PushByDigest })
}

// Store resulting images to the worker's image store and ensure all of
// its blobs are in the content store.
//
// Defaults to `true`.
//
// Ignored if the worker doesn't have image store (when using OCI workers,
// for example).
func (o ExportImageOutput) Store() pulumix.Output[*bool] {
	return pulumix.Apply[ExportImage](o, func(v ExportImage) *bool { return v.Store })
}

// Unpack image after creation (for use with containerd). Defaults to
// `false`.
func (o ExportImageOutput) Unpack() pulumix.Output[*bool] {
	return pulumix.Apply[ExportImage](o, func(v ExportImage) *bool { return v.Unpack })
}

type ExportLocal struct {
	// Output path.
	Dest string `pulumi:"dest"`
}

type ExportLocalArgs struct {
	// Output path.
	Dest pulumix.Input[string] `pulumi:"dest"`
}

func (ExportLocalArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ExportLocal)(nil)).Elem()
}

func (i ExportLocalArgs) ToExportLocalOutput() ExportLocalOutput {
	return i.ToExportLocalOutputWithContext(context.Background())
}

func (i ExportLocalArgs) ToExportLocalOutputWithContext(ctx context.Context) ExportLocalOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExportLocalOutput)
}

func (i *ExportLocalArgs) ToOutput(ctx context.Context) pulumix.Output[*ExportLocalArgs] {
	return pulumix.Val(i)
}

type ExportLocalOutput struct{ *pulumi.OutputState }

func (ExportLocalOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ExportLocal)(nil)).Elem()
}

func (o ExportLocalOutput) ToExportLocalOutput() ExportLocalOutput {
	return o
}

func (o ExportLocalOutput) ToExportLocalOutputWithContext(ctx context.Context) ExportLocalOutput {
	return o
}

func (o ExportLocalOutput) ToOutput(ctx context.Context) pulumix.Output[ExportLocal] {
	return pulumix.Output[ExportLocal]{
		OutputState: o.OutputState,
	}
}

// Output path.
func (o ExportLocalOutput) Dest() pulumix.Output[string] {
	return pulumix.Apply[ExportLocal](o, func(v ExportLocal) string { return v.Dest })
}

type ExportOCI struct {
	// Attach an arbitrary key/value annotation to the image.
	Annotations map[string]string `pulumi:"annotations"`
	// The compression type to use.
	Compression *CompressionType `pulumi:"compression"`
	// Compression level from 0 to 22.
	CompressionLevel *int `pulumi:"compressionLevel"`
	// The local export path.
	Dest *string `pulumi:"dest"`
	// Forcefully apply compression.
	ForceCompression *bool `pulumi:"forceCompression"`
	// Specify images names to export. This is overridden if tags are already specified.
	Names []string `pulumi:"names"`
	// Use OCI media types in exporter manifests.
	OciMediaTypes *bool `pulumi:"ociMediaTypes"`
	// Bundle the output into a tarball layout.
	Tar *bool `pulumi:"tar"`
}

// Defaults sets the appropriate defaults for ExportOCI
func (val *ExportOCI) Defaults() *ExportOCI {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Compression == nil {
		compression_ := CompressionType("gzip")
		tmp.Compression = &compression_
	}
	if tmp.CompressionLevel == nil {
		compressionLevel_ := 0
		tmp.CompressionLevel = &compressionLevel_
	}
	if tmp.ForceCompression == nil {
		forceCompression_ := false
		tmp.ForceCompression = &forceCompression_
	}
	if tmp.OciMediaTypes == nil {
		ociMediaTypes_ := true
		tmp.OciMediaTypes = &ociMediaTypes_
	}
	if tmp.Tar == nil {
		tar_ := true
		tmp.Tar = &tar_
	}
	return &tmp
}

type ExportOCIArgs struct {
	// Attach an arbitrary key/value annotation to the image.
	Annotations pulumix.Input[map[string]string] `pulumi:"annotations"`
	// The compression type to use.
	Compression pulumix.Input[*CompressionType] `pulumi:"compression"`
	// Compression level from 0 to 22.
	CompressionLevel pulumix.Input[*int] `pulumi:"compressionLevel"`
	// The local export path.
	Dest pulumix.Input[*string] `pulumi:"dest"`
	// Forcefully apply compression.
	ForceCompression pulumix.Input[*bool] `pulumi:"forceCompression"`
	// Specify images names to export. This is overridden if tags are already specified.
	Names pulumix.Input[[]string] `pulumi:"names"`
	// Use OCI media types in exporter manifests.
	OciMediaTypes pulumix.Input[*bool] `pulumi:"ociMediaTypes"`
	// Bundle the output into a tarball layout.
	Tar pulumix.Input[*bool] `pulumi:"tar"`
}

// Defaults sets the appropriate defaults for ExportOCIArgs
func (val *ExportOCIArgs) Defaults() *ExportOCIArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Compression == nil {
		tmp.Compression = pulumix.Ptr(CompressionType("gzip"))
	}
	if tmp.CompressionLevel == nil {
		tmp.CompressionLevel = pulumix.Ptr(0)
	}
	if tmp.ForceCompression == nil {
		tmp.ForceCompression = pulumix.Ptr(false)
	}
	if tmp.OciMediaTypes == nil {
		tmp.OciMediaTypes = pulumix.Ptr(true)
	}
	if tmp.Tar == nil {
		tmp.Tar = pulumix.Ptr(true)
	}
	return &tmp
}
func (ExportOCIArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ExportOCI)(nil)).Elem()
}

func (i ExportOCIArgs) ToExportOCIOutput() ExportOCIOutput {
	return i.ToExportOCIOutputWithContext(context.Background())
}

func (i ExportOCIArgs) ToExportOCIOutputWithContext(ctx context.Context) ExportOCIOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExportOCIOutput)
}

func (i *ExportOCIArgs) ToOutput(ctx context.Context) pulumix.Output[*ExportOCIArgs] {
	return pulumix.Val(i)
}

type ExportOCIOutput struct{ *pulumi.OutputState }

func (ExportOCIOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ExportOCI)(nil)).Elem()
}

func (o ExportOCIOutput) ToExportOCIOutput() ExportOCIOutput {
	return o
}

func (o ExportOCIOutput) ToExportOCIOutputWithContext(ctx context.Context) ExportOCIOutput {
	return o
}

func (o ExportOCIOutput) ToOutput(ctx context.Context) pulumix.Output[ExportOCI] {
	return pulumix.Output[ExportOCI]{
		OutputState: o.OutputState,
	}
}

// Attach an arbitrary key/value annotation to the image.
func (o ExportOCIOutput) Annotations() pulumix.MapOutput[string] {
	value := pulumix.Apply[ExportOCI](o, func(v ExportOCI) map[string]string { return v.Annotations })
	return pulumix.MapOutput[string]{OutputState: value.OutputState}
}

// The compression type to use.
func (o ExportOCIOutput) Compression() pulumix.Output[*CompressionType] {
	return pulumix.Apply[ExportOCI](o, func(v ExportOCI) *CompressionType { return v.Compression })
}

// Compression level from 0 to 22.
func (o ExportOCIOutput) CompressionLevel() pulumix.Output[*int] {
	return pulumix.Apply[ExportOCI](o, func(v ExportOCI) *int { return v.CompressionLevel })
}

// The local export path.
func (o ExportOCIOutput) Dest() pulumix.Output[*string] {
	return pulumix.Apply[ExportOCI](o, func(v ExportOCI) *string { return v.Dest })
}

// Forcefully apply compression.
func (o ExportOCIOutput) ForceCompression() pulumix.Output[*bool] {
	return pulumix.Apply[ExportOCI](o, func(v ExportOCI) *bool { return v.ForceCompression })
}

// Specify images names to export. This is overridden if tags are already specified.
func (o ExportOCIOutput) Names() pulumix.ArrayOutput[string] {
	value := pulumix.Apply[ExportOCI](o, func(v ExportOCI) []string { return v.Names })
	return pulumix.ArrayOutput[string]{OutputState: value.OutputState}
}

// Use OCI media types in exporter manifests.
func (o ExportOCIOutput) OciMediaTypes() pulumix.Output[*bool] {
	return pulumix.Apply[ExportOCI](o, func(v ExportOCI) *bool { return v.OciMediaTypes })
}

// Bundle the output into a tarball layout.
func (o ExportOCIOutput) Tar() pulumix.Output[*bool] {
	return pulumix.Apply[ExportOCI](o, func(v ExportOCI) *bool { return v.Tar })
}

type ExportRegistry struct {
	// Attach an arbitrary key/value annotation to the image.
	Annotations map[string]string `pulumi:"annotations"`
	// The compression type to use.
	Compression *CompressionType `pulumi:"compression"`
	// Compression level from 0 to 22.
	CompressionLevel *int `pulumi:"compressionLevel"`
	// Name image with `prefix@<digest>`, used for anonymous images.
	DanglingNamePrefix *string `pulumi:"danglingNamePrefix"`
	// Forcefully apply compression.
	ForceCompression *bool `pulumi:"forceCompression"`
	// Allow pushing to an insecure registry.
	Insecure *bool `pulumi:"insecure"`
	// Add additional canonical name (`name@<digest>`).
	NameCanonical *bool `pulumi:"nameCanonical"`
	// Specify images names to export. This is overridden if tags are already specified.
	Names []string `pulumi:"names"`
	// Use OCI media types in exporter manifests.
	OciMediaTypes *bool `pulumi:"ociMediaTypes"`
	// Push after creating the image. Defaults to `true`.
	Push *bool `pulumi:"push"`
	// Push image without name.
	PushByDigest *bool `pulumi:"pushByDigest"`
	// Store resulting images to the worker's image store and ensure all of
	// its blobs are in the content store.
	//
	// Defaults to `true`.
	//
	// Ignored if the worker doesn't have image store (when using OCI workers,
	// for example).
	Store *bool `pulumi:"store"`
	// Unpack image after creation (for use with containerd). Defaults to
	// `false`.
	Unpack *bool `pulumi:"unpack"`
}

// Defaults sets the appropriate defaults for ExportRegistry
func (val *ExportRegistry) Defaults() *ExportRegistry {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Compression == nil {
		compression_ := CompressionType("gzip")
		tmp.Compression = &compression_
	}
	if tmp.CompressionLevel == nil {
		compressionLevel_ := 0
		tmp.CompressionLevel = &compressionLevel_
	}
	if tmp.ForceCompression == nil {
		forceCompression_ := false
		tmp.ForceCompression = &forceCompression_
	}
	if tmp.OciMediaTypes == nil {
		ociMediaTypes_ := false
		tmp.OciMediaTypes = &ociMediaTypes_
	}
	if tmp.Push == nil {
		push_ := true
		tmp.Push = &push_
	}
	if tmp.Store == nil {
		store_ := true
		tmp.Store = &store_
	}
	return &tmp
}

type ExportRegistryArgs struct {
	// Attach an arbitrary key/value annotation to the image.
	Annotations pulumix.Input[map[string]string] `pulumi:"annotations"`
	// The compression type to use.
	Compression pulumix.Input[*CompressionType] `pulumi:"compression"`
	// Compression level from 0 to 22.
	CompressionLevel pulumix.Input[*int] `pulumi:"compressionLevel"`
	// Name image with `prefix@<digest>`, used for anonymous images.
	DanglingNamePrefix pulumix.Input[*string] `pulumi:"danglingNamePrefix"`
	// Forcefully apply compression.
	ForceCompression pulumix.Input[*bool] `pulumi:"forceCompression"`
	// Allow pushing to an insecure registry.
	Insecure pulumix.Input[*bool] `pulumi:"insecure"`
	// Add additional canonical name (`name@<digest>`).
	NameCanonical pulumix.Input[*bool] `pulumi:"nameCanonical"`
	// Specify images names to export. This is overridden if tags are already specified.
	Names pulumix.Input[[]string] `pulumi:"names"`
	// Use OCI media types in exporter manifests.
	OciMediaTypes pulumix.Input[*bool] `pulumi:"ociMediaTypes"`
	// Push after creating the image. Defaults to `true`.
	Push pulumix.Input[*bool] `pulumi:"push"`
	// Push image without name.
	PushByDigest pulumix.Input[*bool] `pulumi:"pushByDigest"`
	// Store resulting images to the worker's image store and ensure all of
	// its blobs are in the content store.
	//
	// Defaults to `true`.
	//
	// Ignored if the worker doesn't have image store (when using OCI workers,
	// for example).
	Store pulumix.Input[*bool] `pulumi:"store"`
	// Unpack image after creation (for use with containerd). Defaults to
	// `false`.
	Unpack pulumix.Input[*bool] `pulumi:"unpack"`
}

// Defaults sets the appropriate defaults for ExportRegistryArgs
func (val *ExportRegistryArgs) Defaults() *ExportRegistryArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Compression == nil {
		tmp.Compression = pulumix.Ptr(CompressionType("gzip"))
	}
	if tmp.CompressionLevel == nil {
		tmp.CompressionLevel = pulumix.Ptr(0)
	}
	if tmp.ForceCompression == nil {
		tmp.ForceCompression = pulumix.Ptr(false)
	}
	if tmp.OciMediaTypes == nil {
		tmp.OciMediaTypes = pulumix.Ptr(false)
	}
	if tmp.Push == nil {
		tmp.Push = pulumix.Ptr(true)
	}
	if tmp.Store == nil {
		tmp.Store = pulumix.Ptr(true)
	}
	return &tmp
}
func (ExportRegistryArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ExportRegistry)(nil)).Elem()
}

func (i ExportRegistryArgs) ToExportRegistryOutput() ExportRegistryOutput {
	return i.ToExportRegistryOutputWithContext(context.Background())
}

func (i ExportRegistryArgs) ToExportRegistryOutputWithContext(ctx context.Context) ExportRegistryOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExportRegistryOutput)
}

func (i *ExportRegistryArgs) ToOutput(ctx context.Context) pulumix.Output[*ExportRegistryArgs] {
	return pulumix.Val(i)
}

type ExportRegistryOutput struct{ *pulumi.OutputState }

func (ExportRegistryOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ExportRegistry)(nil)).Elem()
}

func (o ExportRegistryOutput) ToExportRegistryOutput() ExportRegistryOutput {
	return o
}

func (o ExportRegistryOutput) ToExportRegistryOutputWithContext(ctx context.Context) ExportRegistryOutput {
	return o
}

func (o ExportRegistryOutput) ToOutput(ctx context.Context) pulumix.Output[ExportRegistry] {
	return pulumix.Output[ExportRegistry]{
		OutputState: o.OutputState,
	}
}

// Attach an arbitrary key/value annotation to the image.
func (o ExportRegistryOutput) Annotations() pulumix.MapOutput[string] {
	value := pulumix.Apply[ExportRegistry](o, func(v ExportRegistry) map[string]string { return v.Annotations })
	return pulumix.MapOutput[string]{OutputState: value.OutputState}
}

// The compression type to use.
func (o ExportRegistryOutput) Compression() pulumix.Output[*CompressionType] {
	return pulumix.Apply[ExportRegistry](o, func(v ExportRegistry) *CompressionType { return v.Compression })
}

// Compression level from 0 to 22.
func (o ExportRegistryOutput) CompressionLevel() pulumix.Output[*int] {
	return pulumix.Apply[ExportRegistry](o, func(v ExportRegistry) *int { return v.CompressionLevel })
}

// Name image with `prefix@<digest>`, used for anonymous images.
func (o ExportRegistryOutput) DanglingNamePrefix() pulumix.Output[*string] {
	return pulumix.Apply[ExportRegistry](o, func(v ExportRegistry) *string { return v.DanglingNamePrefix })
}

// Forcefully apply compression.
func (o ExportRegistryOutput) ForceCompression() pulumix.Output[*bool] {
	return pulumix.Apply[ExportRegistry](o, func(v ExportRegistry) *bool { return v.ForceCompression })
}

// Allow pushing to an insecure registry.
func (o ExportRegistryOutput) Insecure() pulumix.Output[*bool] {
	return pulumix.Apply[ExportRegistry](o, func(v ExportRegistry) *bool { return v.Insecure })
}

// Add additional canonical name (`name@<digest>`).
func (o ExportRegistryOutput) NameCanonical() pulumix.Output[*bool] {
	return pulumix.Apply[ExportRegistry](o, func(v ExportRegistry) *bool { return v.NameCanonical })
}

// Specify images names to export. This is overridden if tags are already specified.
func (o ExportRegistryOutput) Names() pulumix.ArrayOutput[string] {
	value := pulumix.Apply[ExportRegistry](o, func(v ExportRegistry) []string { return v.Names })
	return pulumix.ArrayOutput[string]{OutputState: value.OutputState}
}

// Use OCI media types in exporter manifests.
func (o ExportRegistryOutput) OciMediaTypes() pulumix.Output[*bool] {
	return pulumix.Apply[ExportRegistry](o, func(v ExportRegistry) *bool { return v.OciMediaTypes })
}

// Push after creating the image. Defaults to `true`.
func (o ExportRegistryOutput) Push() pulumix.Output[*bool] {
	return pulumix.Apply[ExportRegistry](o, func(v ExportRegistry) *bool { return v.Push })
}

// Push image without name.
func (o ExportRegistryOutput) PushByDigest() pulumix.Output[*bool] {
	return pulumix.Apply[ExportRegistry](o, func(v ExportRegistry) *bool { return v.PushByDigest })
}

// Store resulting images to the worker's image store and ensure all of
// its blobs are in the content store.
//
// Defaults to `true`.
//
// Ignored if the worker doesn't have image store (when using OCI workers,
// for example).
func (o ExportRegistryOutput) Store() pulumix.Output[*bool] {
	return pulumix.Apply[ExportRegistry](o, func(v ExportRegistry) *bool { return v.Store })
}

// Unpack image after creation (for use with containerd). Defaults to
// `false`.
func (o ExportRegistryOutput) Unpack() pulumix.Output[*bool] {
	return pulumix.Apply[ExportRegistry](o, func(v ExportRegistry) *bool { return v.Unpack })
}

type ExportTar struct {
	// Output path.
	Dest string `pulumi:"dest"`
}

type ExportTarArgs struct {
	// Output path.
	Dest pulumix.Input[string] `pulumi:"dest"`
}

func (ExportTarArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ExportTar)(nil)).Elem()
}

func (i ExportTarArgs) ToExportTarOutput() ExportTarOutput {
	return i.ToExportTarOutputWithContext(context.Background())
}

func (i ExportTarArgs) ToExportTarOutputWithContext(ctx context.Context) ExportTarOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExportTarOutput)
}

func (i *ExportTarArgs) ToOutput(ctx context.Context) pulumix.Output[*ExportTarArgs] {
	return pulumix.Val(i)
}

type ExportTarOutput struct{ *pulumi.OutputState }

func (ExportTarOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ExportTar)(nil)).Elem()
}

func (o ExportTarOutput) ToExportTarOutput() ExportTarOutput {
	return o
}

func (o ExportTarOutput) ToExportTarOutputWithContext(ctx context.Context) ExportTarOutput {
	return o
}

func (o ExportTarOutput) ToOutput(ctx context.Context) pulumix.Output[ExportTar] {
	return pulumix.Output[ExportTar]{
		OutputState: o.OutputState,
	}
}

// Output path.
func (o ExportTarOutput) Dest() pulumix.Output[string] {
	return pulumix.Apply[ExportTar](o, func(v ExportTar) string { return v.Dest })
}

type Registry struct {
	// The registry's address (e.g. "docker.io").
	Address string `pulumi:"address"`
	// Password or token for the registry.
	Password *string `pulumi:"password"`
	// Username for the registry.
	Username *string `pulumi:"username"`
}

type RegistryArgs struct {
	// The registry's address (e.g. "docker.io").
	Address pulumix.Input[string] `pulumi:"address"`
	// Password or token for the registry.
	Password pulumix.Input[*string] `pulumi:"password"`
	// Username for the registry.
	Username pulumix.Input[*string] `pulumi:"username"`
}

func (RegistryArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Registry)(nil)).Elem()
}

func (i RegistryArgs) ToRegistryOutput() RegistryOutput {
	return i.ToRegistryOutputWithContext(context.Background())
}

func (i RegistryArgs) ToRegistryOutputWithContext(ctx context.Context) RegistryOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RegistryOutput)
}

func (i *RegistryArgs) ToOutput(ctx context.Context) pulumix.Output[*RegistryArgs] {
	return pulumix.Val(i)
}

type RegistryOutput struct{ *pulumi.OutputState }

func (RegistryOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Registry)(nil)).Elem()
}

func (o RegistryOutput) ToRegistryOutput() RegistryOutput {
	return o
}

func (o RegistryOutput) ToRegistryOutputWithContext(ctx context.Context) RegistryOutput {
	return o
}

func (o RegistryOutput) ToOutput(ctx context.Context) pulumix.Output[Registry] {
	return pulumix.Output[Registry]{
		OutputState: o.OutputState,
	}
}

// The registry's address (e.g. "docker.io").
func (o RegistryOutput) Address() pulumix.Output[string] {
	return pulumix.Apply[Registry](o, func(v Registry) string { return v.Address })
}

// Password or token for the registry.
func (o RegistryOutput) Password() pulumix.Output[*string] {
	return pulumix.Apply[Registry](o, func(v Registry) *string { return v.Password })
}

// Username for the registry.
func (o RegistryOutput) Username() pulumix.Output[*string] {
	return pulumix.Apply[Registry](o, func(v Registry) *string { return v.Username })
}

type SSH struct {
	// Useful for distinguishing different servers that are part of the same
	// build.
	//
	// A value of `default` is appropriate if only dealing with a single host.
	Id string `pulumi:"id"`
	// SSH agent socket or private keys to expose to the build under the given
	// identifier.
	//
	// Defaults to `[$SSH_AUTH_SOCK]`.
	//
	// Note that your keys are **not** automatically added when using an
	// agent. Run `ssh-add -l` locally to confirm which public keys are
	// visible to the agent; these will be exposed to your build.
	Paths []string `pulumi:"paths"`
}

type SSHArgs struct {
	// Useful for distinguishing different servers that are part of the same
	// build.
	//
	// A value of `default` is appropriate if only dealing with a single host.
	Id pulumix.Input[string] `pulumi:"id"`
	// SSH agent socket or private keys to expose to the build under the given
	// identifier.
	//
	// Defaults to `[$SSH_AUTH_SOCK]`.
	//
	// Note that your keys are **not** automatically added when using an
	// agent. Run `ssh-add -l` locally to confirm which public keys are
	// visible to the agent; these will be exposed to your build.
	Paths pulumix.Input[[]string] `pulumi:"paths"`
}

func (SSHArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SSH)(nil)).Elem()
}

func (i SSHArgs) ToSSHOutput() SSHOutput {
	return i.ToSSHOutputWithContext(context.Background())
}

func (i SSHArgs) ToSSHOutputWithContext(ctx context.Context) SSHOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SSHOutput)
}

func (i *SSHArgs) ToOutput(ctx context.Context) pulumix.Output[*SSHArgs] {
	return pulumix.Val(i)
}

type SSHOutput struct{ *pulumi.OutputState }

func (SSHOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SSH)(nil)).Elem()
}

func (o SSHOutput) ToSSHOutput() SSHOutput {
	return o
}

func (o SSHOutput) ToSSHOutputWithContext(ctx context.Context) SSHOutput {
	return o
}

func (o SSHOutput) ToOutput(ctx context.Context) pulumix.Output[SSH] {
	return pulumix.Output[SSH]{
		OutputState: o.OutputState,
	}
}

// Useful for distinguishing different servers that are part of the same
// build.
//
// A value of `default` is appropriate if only dealing with a single host.
func (o SSHOutput) Id() pulumix.Output[string] {
	return pulumix.Apply[SSH](o, func(v SSH) string { return v.Id })
}

// SSH agent socket or private keys to expose to the build under the given
// identifier.
//
// Defaults to `[$SSH_AUTH_SOCK]`.
//
// Note that your keys are **not** automatically added when using an
// agent. Run `ssh-add -l` locally to confirm which public keys are
// visible to the agent; these will be exposed to your build.
func (o SSHOutput) Paths() pulumix.ArrayOutput[string] {
	value := pulumix.Apply[SSH](o, func(v SSH) []string { return v.Paths })
	return pulumix.ArrayOutput[string]{OutputState: value.OutputState}
}

func init() {
	pulumi.RegisterOutputType(BuildContextOutput{})
	pulumi.RegisterOutputType(BuilderConfigOutput{})
	pulumi.RegisterOutputType(CacheFromOutput{})
	pulumi.RegisterOutputType(CacheFromAzureBlobOutput{})
	pulumi.RegisterOutputType(CacheFromGitHubActionsOutput{})
	pulumi.RegisterOutputType(CacheFromLocalOutput{})
	pulumi.RegisterOutputType(CacheFromRegistryOutput{})
	pulumi.RegisterOutputType(CacheFromS3Output{})
	pulumi.RegisterOutputType(CacheToOutput{})
	pulumi.RegisterOutputType(CacheToAzureBlobOutput{})
	pulumi.RegisterOutputType(CacheToGitHubActionsOutput{})
	pulumi.RegisterOutputType(CacheToInlineOutput{})
	pulumi.RegisterOutputType(CacheToLocalOutput{})
	pulumi.RegisterOutputType(CacheToRegistryOutput{})
	pulumi.RegisterOutputType(CacheToS3Output{})
	pulumi.RegisterOutputType(ContextOutput{})
	pulumi.RegisterOutputType(DockerfileOutput{})
	pulumi.RegisterOutputType(ExportOutput{})
	pulumi.RegisterOutputType(ExportCacheOnlyOutput{})
	pulumi.RegisterOutputType(ExportDockerOutput{})
	pulumi.RegisterOutputType(ExportImageOutput{})
	pulumi.RegisterOutputType(ExportLocalOutput{})
	pulumi.RegisterOutputType(ExportOCIOutput{})
	pulumi.RegisterOutputType(ExportRegistryOutput{})
	pulumi.RegisterOutputType(ExportTarOutput{})
	pulumi.RegisterOutputType(RegistryOutput{})
	pulumi.RegisterOutputType(SSHOutput{})
}
