{
  "name": "dockerbuild",
  "displayName": "dockerbuild",
  "version": "0.0.2-alpha.1711751834+fe4de036",
  "description": "A Pulumi provider for Docker buildx",
  "keywords": [
    "docker",
    "buildkit",
    "buildx"
  ],
  "homepage": "https://pulumi.io",
  "license": "Apache-2.0",
  "repository": "https://github.com/pulumi/pulumi-dockerbuild",
  "pluginDownloadURL": "github.com/pulumi/pulumi-dockerbuild",
  "publisher": "pulumi",
  "meta": {
    "moduleFormat": "(.*)"
  },
  "language": {
    "csharp": {
      "packageReferences": {
        "Pulumi": "3.*"
      }
    },
    "go": {
      "importBasePath": "github.com/pulumi/pulumi-dockerbuild/sdk/go/dockerbuild",
      "packageImportAliases": {
        "github.com/pulumi/pulumi-dockerbuild/sdk/go/dockerbuild": "dockerbuild"
      },
      "generics": "side-by-side"
    },
    "java": {
      "basePackage": "",
      "buildFiles": "gradle",
      "dependencies": {
        "com.google.code.findbugs:jsr305": "3.0.2",
        "com.google.code.gson:gson": "2.8.9",
        "com.pulumi:pulumi": "0.9.9"
      },
      "gradleNexusPublishPluginVersion": "1.1.0",
      "gradleTest": ""
    },
    "nodejs": {
      "dependencies": {
        "@pulumi/pulumi": "^3.0.0"
      }
    },
    "python": {
      "requires": {
        "pulumi": "\u003e=3.0.0,\u003c4.0.0"
      },
      "pyproject": {
        "enabled": true
      }
    }
  },
  "config": {
    "variables": {
      "host": {
        "type": "string",
        "description": "The build daemon's address.",
        "default": "",
        "defaultInfo": {
          "environment": [
            "DOCKER_HOST"
          ]
        }
      },
      "registries": {
        "type": "array",
        "items": {
          "$ref": "#/types/dockerbuild:index:Registry"
        }
      }
    }
  },
  "types": {
    "dockerbuild:index:BuildContext": {
      "properties": {
        "location": {
          "type": "string",
          "description": "Resources to use for build context.\n\nThe location can be:\n* A relative or absolute path to a local directory (`.`, `./app`,\n  `/app`, etc.).\n* A remote URL of a Git repository, tarball, or plain text file\n  (`https://github.com/user/myrepo.git`, `http://server/context.tar.gz`,\n  etc.)."
        },
        "named": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/types/dockerbuild:index:Context"
          },
          "description": "Additional build contexts to use.\n\nThese contexts are accessed with `FROM name` or `--from=name`\nstatements when using Dockerfile 1.4+ syntax.\n\nValues can be local paths, HTTP URLs, or  `docker-image://` images."
        }
      },
      "type": "object",
      "required": [
        "location"
      ]
    },
    "dockerbuild:index:BuilderConfig": {
      "properties": {
        "name": {
          "type": "string",
          "description": "Name of an existing buildx builder to use.\n\nOnly `docker-container`, `kubernetes`, or `remote` drivers are\nsupported. The legacy `docker` driver is not supported.\n\nEquivalent to Docker's `--builder` flag."
        }
      },
      "type": "object"
    },
    "dockerbuild:index:CacheFrom": {
      "properties": {
        "azblob": {
          "$ref": "#/types/dockerbuild:index:CacheFromAzureBlob",
          "description": "Upload build caches to Azure's blob storage service."
        },
        "disabled": {
          "type": "boolean",
          "description": "When `true` this entry will be excluded. Defaults to `false`."
        },
        "gha": {
          "$ref": "#/types/dockerbuild:index:CacheFromGitHubActions",
          "description": "Recommended for use with GitHub Actions workflows.\n\nAn action like `crazy-max/ghaction-github-runtime` is recommended to\nexpose appropriate credentials to your GitHub workflow."
        },
        "local": {
          "$ref": "#/types/dockerbuild:index:CacheFromLocal",
          "description": "A simple backend which caches images on your local filesystem."
        },
        "raw": {
          "type": "string",
          "description": "A raw string as you would provide it to the Docker CLI (e.g.,\n`type=inline`)."
        },
        "registry": {
          "$ref": "#/types/dockerbuild:index:CacheFromRegistry",
          "description": "Upload build caches to remote registries."
        },
        "s3": {
          "$ref": "#/types/dockerbuild:index:CacheFromS3",
          "description": "Upload build caches to AWS S3 or an S3-compatible services such as\nMinIO."
        }
      },
      "type": "object"
    },
    "dockerbuild:index:CacheFromAzureBlob": {
      "properties": {
        "accountUrl": {
          "type": "string",
          "description": "Base URL of the storage account."
        },
        "name": {
          "type": "string",
          "description": "The name of the cache image."
        },
        "secretAccessKey": {
          "type": "string",
          "description": "Blob storage account key.",
          "secret": true
        }
      },
      "type": "object",
      "required": [
        "name"
      ]
    },
    "dockerbuild:index:CacheFromGitHubActions": {
      "properties": {
        "scope": {
          "type": "string",
          "description": "The scope to use for cache keys. Defaults to `buildkit`.\n\nThis should be set if building and caching multiple images in one\nworkflow, otherwise caches will overwrite each other.",
          "default": "",
          "defaultInfo": {
            "environment": [
              "buildkit"
            ]
          }
        },
        "token": {
          "type": "string",
          "description": "The GitHub Actions token to use. This is not a personal access tokens\nand is typically generated automatically as part of each job.\n\nDefaults to `$ACTIONS_RUNTIME_TOKEN`, although a separate action like\n`crazy-max/ghaction-github-runtime` is recommended to expose this\nenvironment variable to your jobs.",
          "default": "",
          "defaultInfo": {
            "environment": [
              "ACTIONS_RUNTIME_TOKEN"
            ]
          },
          "secret": true
        },
        "url": {
          "type": "string",
          "description": "The cache server URL to use for artifacts.\n\nDefaults to `$ACTIONS_RUNTIME_URL`, although a separate action like\n`crazy-max/ghaction-github-runtime` is recommended to expose this\nenvironment variable to your jobs.",
          "default": "",
          "defaultInfo": {
            "environment": [
              "ACTIONS_RUNTIME_URL"
            ]
          }
        }
      },
      "type": "object"
    },
    "dockerbuild:index:CacheFromLocal": {
      "properties": {
        "digest": {
          "type": "string",
          "description": "Digest of manifest to import."
        },
        "src": {
          "type": "string",
          "description": "Path of the local directory where cache gets imported from."
        }
      },
      "type": "object",
      "required": [
        "src"
      ]
    },
    "dockerbuild:index:CacheFromRegistry": {
      "properties": {
        "ref": {
          "type": "string",
          "description": "Fully qualified name of the cache image to import."
        }
      },
      "type": "object",
      "required": [
        "ref"
      ]
    },
    "dockerbuild:index:CacheFromS3": {
      "properties": {
        "accessKeyId": {
          "type": "string",
          "description": "Defaults to `$AWS_ACCESS_KEY_ID`.",
          "default": "",
          "defaultInfo": {
            "environment": [
              "AWS_ACCESS_KEY_ID"
            ]
          }
        },
        "blobsPrefix": {
          "type": "string",
          "description": "Prefix to prepend to blob filenames."
        },
        "bucket": {
          "type": "string",
          "description": "Name of the S3 bucket."
        },
        "endpointUrl": {
          "type": "string",
          "description": "Endpoint of the S3 bucket."
        },
        "manifestsPrefix": {
          "type": "string",
          "description": "Prefix to prepend on manifest filenames."
        },
        "name": {
          "type": "string",
          "description": "Name of the cache image."
        },
        "region": {
          "type": "string",
          "description": "The geographic location of the bucket. Defaults to `$AWS_REGION`.",
          "default": "",
          "defaultInfo": {
            "environment": [
              "AWS_REGION"
            ]
          }
        },
        "secretAccessKey": {
          "type": "string",
          "description": "Defaults to `$AWS_SECRET_ACCESS_KEY`.",
          "default": "",
          "defaultInfo": {
            "environment": [
              "AWS_SECRET_ACCESS_KEY"
            ]
          },
          "secret": true
        },
        "sessionToken": {
          "type": "string",
          "description": "Defaults to `$AWS_SESSION_TOKEN`.",
          "default": "",
          "defaultInfo": {
            "environment": [
              "AWS_SESSION_TOKEN"
            ]
          },
          "secret": true
        },
        "usePathStyle": {
          "type": "boolean",
          "description": "Uses `bucket` in the URL instead of hostname when `true`."
        }
      },
      "type": "object",
      "required": [
        "bucket",
        "region"
      ]
    },
    "dockerbuild:index:CacheMode": {
      "type": "string",
      "enum": [
        {
          "description": "Only layers that are exported into the resulting image are cached.",
          "value": "min"
        },
        {
          "description": "All layers are cached, even those of intermediate steps.",
          "value": "max"
        }
      ]
    },
    "dockerbuild:index:CacheTo": {
      "properties": {
        "azblob": {
          "$ref": "#/types/dockerbuild:index:CacheToAzureBlob",
          "description": "Push cache to Azure's blob storage service."
        },
        "disabled": {
          "type": "boolean",
          "description": "When `true` this entry will be excluded. Defaults to `false`."
        },
        "gha": {
          "$ref": "#/types/dockerbuild:index:CacheToGitHubActions",
          "description": "Recommended for use with GitHub Actions workflows.\n\nAn action like `crazy-max/ghaction-github-runtime` is recommended to\nexpose appropriate credentials to your GitHub workflow."
        },
        "inline": {
          "$ref": "#/types/dockerbuild:index:CacheToInline",
          "description": "The inline cache storage backend is the simplest implementation to get\nstarted with, but it does not handle multi-stage builds. Consider the\n`registry` cache backend instead."
        },
        "local": {
          "$ref": "#/types/dockerbuild:index:CacheToLocal",
          "description": "A simple backend which caches imagines on your local filesystem."
        },
        "raw": {
          "type": "string",
          "description": "A raw string as you would provide it to the Docker CLI (e.g.,\n`type=inline`)"
        },
        "registry": {
          "$ref": "#/types/dockerbuild:index:CacheToRegistry",
          "description": "Push caches to remote registries. Incompatible with the `docker` build\ndriver."
        },
        "s3": {
          "$ref": "#/types/dockerbuild:index:CacheToS3",
          "description": "Push cache to AWS S3 or S3-compatible services such as MinIO."
        }
      },
      "type": "object"
    },
    "dockerbuild:index:CacheToAzureBlob": {
      "properties": {
        "accountUrl": {
          "type": "string",
          "description": "Base URL of the storage account."
        },
        "ignoreError": {
          "type": "boolean",
          "description": "Ignore errors caused by failed cache exports.",
          "default": false
        },
        "mode": {
          "$ref": "#/types/dockerbuild:index:CacheMode",
          "description": "The cache mode to use. Defaults to `min`.",
          "default": "min"
        },
        "name": {
          "type": "string",
          "description": "The name of the cache image."
        },
        "secretAccessKey": {
          "type": "string",
          "description": "Blob storage account key.",
          "secret": true
        }
      },
      "type": "object",
      "required": [
        "name"
      ]
    },
    "dockerbuild:index:CacheToGitHubActions": {
      "properties": {
        "ignoreError": {
          "type": "boolean",
          "description": "Ignore errors caused by failed cache exports.",
          "default": false
        },
        "mode": {
          "$ref": "#/types/dockerbuild:index:CacheMode",
          "description": "The cache mode to use. Defaults to `min`.",
          "default": "min"
        },
        "scope": {
          "type": "string",
          "description": "The scope to use for cache keys. Defaults to `buildkit`.\n\nThis should be set if building and caching multiple images in one\nworkflow, otherwise caches will overwrite each other.",
          "default": "",
          "defaultInfo": {
            "environment": [
              "buildkit"
            ]
          }
        },
        "token": {
          "type": "string",
          "description": "The GitHub Actions token to use. This is not a personal access tokens\nand is typically generated automatically as part of each job.\n\nDefaults to `$ACTIONS_RUNTIME_TOKEN`, although a separate action like\n`crazy-max/ghaction-github-runtime` is recommended to expose this\nenvironment variable to your jobs.",
          "default": "",
          "defaultInfo": {
            "environment": [
              "ACTIONS_RUNTIME_TOKEN"
            ]
          },
          "secret": true
        },
        "url": {
          "type": "string",
          "description": "The cache server URL to use for artifacts.\n\nDefaults to `$ACTIONS_RUNTIME_URL`, although a separate action like\n`crazy-max/ghaction-github-runtime` is recommended to expose this\nenvironment variable to your jobs.",
          "default": "",
          "defaultInfo": {
            "environment": [
              "ACTIONS_RUNTIME_URL"
            ]
          }
        }
      },
      "type": "object"
    },
    "dockerbuild:index:CacheToInline": {
      "description": "Include an inline cache with the exported image.",
      "type": "object"
    },
    "dockerbuild:index:CacheToLocal": {
      "properties": {
        "compression": {
          "$ref": "#/types/dockerbuild:index:CompressionType",
          "description": "The compression type to use.",
          "default": "gzip"
        },
        "compressionLevel": {
          "type": "integer",
          "description": "Compression level from 0 to 22.",
          "default": 0
        },
        "dest": {
          "type": "string",
          "description": "Path of the local directory to export the cache."
        },
        "forceCompression": {
          "type": "boolean",
          "description": "Forcefully apply compression.",
          "default": false
        },
        "ignoreError": {
          "type": "boolean",
          "description": "Ignore errors caused by failed cache exports.",
          "default": false
        },
        "mode": {
          "$ref": "#/types/dockerbuild:index:CacheMode",
          "description": "The cache mode to use. Defaults to `min`.",
          "default": "min"
        }
      },
      "type": "object",
      "required": [
        "dest"
      ]
    },
    "dockerbuild:index:CacheToRegistry": {
      "properties": {
        "compression": {
          "$ref": "#/types/dockerbuild:index:CompressionType",
          "description": "The compression type to use.",
          "default": "gzip"
        },
        "compressionLevel": {
          "type": "integer",
          "description": "Compression level from 0 to 22.",
          "default": 0
        },
        "forceCompression": {
          "type": "boolean",
          "description": "Forcefully apply compression.",
          "default": false
        },
        "ignoreError": {
          "type": "boolean",
          "description": "Ignore errors caused by failed cache exports.",
          "default": false
        },
        "imageManifest": {
          "type": "boolean",
          "description": "Export cache manifest as an OCI-compatible image manifest instead of a\nmanifest list. Requires `ociMediaTypes` to also be `true`.\n\nSome registries like AWS ECR will not work with caching if this is\n`false`.\n\nDefaults to `false` to match Docker's default behavior.",
          "default": false
        },
        "mode": {
          "$ref": "#/types/dockerbuild:index:CacheMode",
          "description": "The cache mode to use. Defaults to `min`.",
          "default": "min"
        },
        "ociMediaTypes": {
          "type": "boolean",
          "description": "Whether to use OCI media types in exported manifests. Defaults to\n`true`.",
          "default": true
        },
        "ref": {
          "type": "string",
          "description": "Fully qualified name of the cache image to import."
        }
      },
      "type": "object",
      "required": [
        "ref"
      ]
    },
    "dockerbuild:index:CacheToS3": {
      "properties": {
        "accessKeyId": {
          "type": "string",
          "description": "Defaults to `$AWS_ACCESS_KEY_ID`.",
          "default": "",
          "defaultInfo": {
            "environment": [
              "AWS_ACCESS_KEY_ID"
            ]
          }
        },
        "blobsPrefix": {
          "type": "string",
          "description": "Prefix to prepend to blob filenames."
        },
        "bucket": {
          "type": "string",
          "description": "Name of the S3 bucket."
        },
        "endpointUrl": {
          "type": "string",
          "description": "Endpoint of the S3 bucket."
        },
        "ignoreError": {
          "type": "boolean",
          "description": "Ignore errors caused by failed cache exports.",
          "default": false
        },
        "manifestsPrefix": {
          "type": "string",
          "description": "Prefix to prepend on manifest filenames."
        },
        "mode": {
          "$ref": "#/types/dockerbuild:index:CacheMode",
          "description": "The cache mode to use. Defaults to `min`.",
          "default": "min"
        },
        "name": {
          "type": "string",
          "description": "Name of the cache image."
        },
        "region": {
          "type": "string",
          "description": "The geographic location of the bucket. Defaults to `$AWS_REGION`.",
          "default": "",
          "defaultInfo": {
            "environment": [
              "AWS_REGION"
            ]
          }
        },
        "secretAccessKey": {
          "type": "string",
          "description": "Defaults to `$AWS_SECRET_ACCESS_KEY`.",
          "default": "",
          "defaultInfo": {
            "environment": [
              "AWS_SECRET_ACCESS_KEY"
            ]
          },
          "secret": true
        },
        "sessionToken": {
          "type": "string",
          "description": "Defaults to `$AWS_SESSION_TOKEN`.",
          "default": "",
          "defaultInfo": {
            "environment": [
              "AWS_SESSION_TOKEN"
            ]
          },
          "secret": true
        },
        "usePathStyle": {
          "type": "boolean",
          "description": "Uses `bucket` in the URL instead of hostname when `true`."
        }
      },
      "type": "object",
      "required": [
        "bucket",
        "region"
      ]
    },
    "dockerbuild:index:CompressionType": {
      "type": "string",
      "enum": [
        {
          "description": "Use `gzip` for compression.",
          "value": "gzip"
        },
        {
          "description": "Use `estargz` for compression.",
          "value": "estargz"
        },
        {
          "description": "Use `zstd` for compression.",
          "value": "zstd"
        }
      ]
    },
    "dockerbuild:index:Context": {
      "properties": {
        "location": {
          "type": "string",
          "description": "Resources to use for build context.\n\nThe location can be:\n* A relative or absolute path to a local directory (`.`, `./app`,\n  `/app`, etc.).\n* A remote URL of a Git repository, tarball, or plain text file\n  (`https://github.com/user/myrepo.git`, `http://server/context.tar.gz`,\n  etc.)."
        }
      },
      "type": "object",
      "required": [
        "location"
      ]
    },
    "dockerbuild:index:Dockerfile": {
      "properties": {
        "inline": {
          "type": "string",
          "description": "Raw Dockerfile contents.\n\nConflicts with `location`.\n\nEquivalent to invoking Docker with `-f -`."
        },
        "location": {
          "type": "string",
          "description": "Location of the Dockerfile to use.\n\nCan be a relative or absolute path to a local file, or a remote URL.\n\nDefaults to `${context.location}/Dockerfile` if context is on-disk.\n\nConflicts with `inline`."
        }
      },
      "type": "object"
    },
    "dockerbuild:index:Export": {
      "properties": {
        "cacheonly": {
          "$ref": "#/types/dockerbuild:index:ExportCacheOnly",
          "description": "A no-op export. Helpful for silencing the 'no exports' warning if you\njust want to populate caches."
        },
        "disabled": {
          "type": "boolean",
          "description": "When `true` this entry will be excluded. Defaults to `false`."
        },
        "docker": {
          "$ref": "#/types/dockerbuild:index:ExportDocker",
          "description": "Export as a Docker image layout."
        },
        "image": {
          "$ref": "#/types/dockerbuild:index:ExportImage",
          "description": "Outputs the build result into a container image format."
        },
        "local": {
          "$ref": "#/types/dockerbuild:index:ExportLocal",
          "description": "Export to a local directory as files and directories."
        },
        "oci": {
          "$ref": "#/types/dockerbuild:index:ExportOCI",
          "description": "Identical to the Docker exporter but uses OCI media types by default."
        },
        "raw": {
          "type": "string",
          "description": "A raw string as you would provide it to the Docker CLI (e.g.,\n`type=docker`)"
        },
        "registry": {
          "$ref": "#/types/dockerbuild:index:ExportRegistry",
          "description": "Identical to the Image exporter, but pushes by default."
        },
        "tar": {
          "$ref": "#/types/dockerbuild:index:ExportTar",
          "description": "Export to a local directory as a tarball."
        }
      },
      "type": "object"
    },
    "dockerbuild:index:ExportCacheOnly": {
      "type": "object"
    },
    "dockerbuild:index:ExportDocker": {
      "properties": {
        "annotations": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Attach an arbitrary key/value annotation to the image."
        },
        "compression": {
          "$ref": "#/types/dockerbuild:index:CompressionType",
          "description": "The compression type to use.",
          "default": "gzip"
        },
        "compressionLevel": {
          "type": "integer",
          "description": "Compression level from 0 to 22.",
          "default": 0
        },
        "dest": {
          "type": "string",
          "description": "The local export path."
        },
        "forceCompression": {
          "type": "boolean",
          "description": "Forcefully apply compression.",
          "default": false
        },
        "names": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Specify images names to export. This is overridden if tags are already specified."
        },
        "ociMediaTypes": {
          "type": "boolean",
          "description": "Use OCI media types in exporter manifests.",
          "default": false
        },
        "tar": {
          "type": "boolean",
          "description": "Bundle the output into a tarball layout.",
          "default": true
        }
      },
      "type": "object"
    },
    "dockerbuild:index:ExportImage": {
      "properties": {
        "annotations": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Attach an arbitrary key/value annotation to the image."
        },
        "compression": {
          "$ref": "#/types/dockerbuild:index:CompressionType",
          "description": "The compression type to use.",
          "default": "gzip"
        },
        "compressionLevel": {
          "type": "integer",
          "description": "Compression level from 0 to 22.",
          "default": 0
        },
        "danglingNamePrefix": {
          "type": "string",
          "description": "Name image with `prefix@\u003cdigest\u003e`, used for anonymous images."
        },
        "forceCompression": {
          "type": "boolean",
          "description": "Forcefully apply compression.",
          "default": false
        },
        "insecure": {
          "type": "boolean",
          "description": "Allow pushing to an insecure registry."
        },
        "nameCanonical": {
          "type": "boolean",
          "description": "Add additional canonical name (`name@\u003cdigest\u003e`)."
        },
        "names": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Specify images names to export. This is overridden if tags are already specified."
        },
        "ociMediaTypes": {
          "type": "boolean",
          "description": "Use OCI media types in exporter manifests.",
          "default": false
        },
        "push": {
          "type": "boolean",
          "description": "Push after creating the image. Defaults to `false`."
        },
        "pushByDigest": {
          "type": "boolean",
          "description": "Push image without name."
        },
        "store": {
          "type": "boolean",
          "description": "Store resulting images to the worker's image store and ensure all of\nits blobs are in the content store.\n\nDefaults to `true`.\n\nIgnored if the worker doesn't have image store (when using OCI workers,\nfor example).",
          "default": true
        },
        "unpack": {
          "type": "boolean",
          "description": "Unpack image after creation (for use with containerd). Defaults to\n`false`."
        }
      },
      "type": "object"
    },
    "dockerbuild:index:ExportLocal": {
      "properties": {
        "dest": {
          "type": "string",
          "description": "Output path."
        }
      },
      "type": "object",
      "required": [
        "dest"
      ]
    },
    "dockerbuild:index:ExportOCI": {
      "properties": {
        "annotations": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Attach an arbitrary key/value annotation to the image."
        },
        "compression": {
          "$ref": "#/types/dockerbuild:index:CompressionType",
          "description": "The compression type to use.",
          "default": "gzip"
        },
        "compressionLevel": {
          "type": "integer",
          "description": "Compression level from 0 to 22.",
          "default": 0
        },
        "dest": {
          "type": "string",
          "description": "The local export path."
        },
        "forceCompression": {
          "type": "boolean",
          "description": "Forcefully apply compression.",
          "default": false
        },
        "names": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Specify images names to export. This is overridden if tags are already specified."
        },
        "ociMediaTypes": {
          "type": "boolean",
          "description": "Use OCI media types in exporter manifests.",
          "default": true
        },
        "tar": {
          "type": "boolean",
          "description": "Bundle the output into a tarball layout.",
          "default": true
        }
      },
      "type": "object"
    },
    "dockerbuild:index:ExportRegistry": {
      "properties": {
        "annotations": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Attach an arbitrary key/value annotation to the image."
        },
        "compression": {
          "$ref": "#/types/dockerbuild:index:CompressionType",
          "description": "The compression type to use.",
          "default": "gzip"
        },
        "compressionLevel": {
          "type": "integer",
          "description": "Compression level from 0 to 22.",
          "default": 0
        },
        "danglingNamePrefix": {
          "type": "string",
          "description": "Name image with `prefix@\u003cdigest\u003e`, used for anonymous images."
        },
        "forceCompression": {
          "type": "boolean",
          "description": "Forcefully apply compression.",
          "default": false
        },
        "insecure": {
          "type": "boolean",
          "description": "Allow pushing to an insecure registry."
        },
        "nameCanonical": {
          "type": "boolean",
          "description": "Add additional canonical name (`name@\u003cdigest\u003e`)."
        },
        "names": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Specify images names to export. This is overridden if tags are already specified."
        },
        "ociMediaTypes": {
          "type": "boolean",
          "description": "Use OCI media types in exporter manifests.",
          "default": false
        },
        "push": {
          "type": "boolean",
          "description": "Push after creating the image. Defaults to `true`.",
          "default": true
        },
        "pushByDigest": {
          "type": "boolean",
          "description": "Push image without name."
        },
        "store": {
          "type": "boolean",
          "description": "Store resulting images to the worker's image store and ensure all of\nits blobs are in the content store.\n\nDefaults to `true`.\n\nIgnored if the worker doesn't have image store (when using OCI workers,\nfor example).",
          "default": true
        },
        "unpack": {
          "type": "boolean",
          "description": "Unpack image after creation (for use with containerd). Defaults to\n`false`."
        }
      },
      "type": "object"
    },
    "dockerbuild:index:ExportTar": {
      "properties": {
        "dest": {
          "type": "string",
          "description": "Output path."
        }
      },
      "type": "object",
      "required": [
        "dest"
      ]
    },
    "dockerbuild:index:NetworkMode": {
      "type": "string",
      "enum": [
        {
          "description": "The default sandbox network mode.",
          "value": "default"
        },
        {
          "description": "Host network mode.",
          "value": "host"
        },
        {
          "description": "Disable network access.",
          "value": "none"
        }
      ]
    },
    "dockerbuild:index:Platform": {
      "type": "string",
      "enum": [
        {
          "value": "darwin/386"
        },
        {
          "value": "darwin/amd64"
        },
        {
          "value": "darwin/arm"
        },
        {
          "value": "darwin/arm64"
        },
        {
          "value": "dragonfly/amd64"
        },
        {
          "value": "freebsd/386"
        },
        {
          "value": "freebsd/amd64"
        },
        {
          "value": "freebsd/arm"
        },
        {
          "value": "linux/386"
        },
        {
          "value": "linux/amd64"
        },
        {
          "value": "linux/arm"
        },
        {
          "value": "linux/arm64"
        },
        {
          "value": "linux/mips64"
        },
        {
          "value": "linux/mips64le"
        },
        {
          "value": "linux/ppc64le"
        },
        {
          "value": "linux/riscv64"
        },
        {
          "value": "linux/s390x"
        },
        {
          "value": "netbsd/386"
        },
        {
          "value": "netbsd/amd64"
        },
        {
          "value": "netbsd/arm"
        },
        {
          "value": "openbsd/386"
        },
        {
          "value": "openbsd/amd64"
        },
        {
          "value": "openbsd/arm"
        },
        {
          "value": "plan9/386"
        },
        {
          "value": "plan9/amd64"
        },
        {
          "value": "solaris/amd64"
        },
        {
          "value": "windows/386"
        },
        {
          "value": "windows/amd64"
        }
      ]
    },
    "dockerbuild:index:Registry": {
      "properties": {
        "address": {
          "type": "string",
          "description": "The registry's address (e.g. \"docker.io\")."
        },
        "password": {
          "type": "string",
          "description": "Password or token for the registry.",
          "secret": true
        },
        "username": {
          "type": "string",
          "description": "Username for the registry."
        }
      },
      "type": "object",
      "required": [
        "address"
      ]
    },
    "dockerbuild:index:SSH": {
      "properties": {
        "id": {
          "type": "string",
          "description": "Useful for distinguishing different servers that are part of the same\nbuild.\n\nA value of `default` is appropriate if only dealing with a single host."
        },
        "paths": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "SSH agent socket or private keys to expose to the build under the given\nidentifier.\n\nDefaults to `[$SSH_AUTH_SOCK]`.\n\nNote that your keys are **not** automatically added when using an\nagent. Run `ssh-add -l` locally to confirm which public keys are\nvisible to the agent; these will be exposed to your build."
        }
      },
      "type": "object",
      "required": [
        "id"
      ]
    }
  },
  "provider": {
    "properties": {
      "host": {
        "type": "string",
        "description": "The build daemon's address.",
        "default": "",
        "defaultInfo": {
          "environment": [
            "DOCKER_HOST"
          ]
        }
      }
    },
    "type": "object",
    "inputProperties": {
      "host": {
        "type": "string",
        "description": "The build daemon's address.",
        "default": "",
        "defaultInfo": {
          "environment": [
            "DOCKER_HOST"
          ]
        }
      },
      "registries": {
        "type": "array",
        "items": {
          "$ref": "#/types/dockerbuild:index:Registry"
        }
      }
    }
  },
  "resources": {
    "dockerbuild:index:Image": {
      "description": "A Docker image built using buildx -- Docker's interface to the improved\nBuildKit backend.\n\n## Stability\n\n**This resource is experimental and subject to change.**\n\nAPI types are unstable. Subsequent releases _may_ require manual edits\nto your state file(s) in order to adopt API changes.\n\n`retainOnDelete: true` is recommended with this resource until it is\nstable. This enables future API changes to be adopted more easily by renaming\nresources.\n\nOnly use this resource if you understand and accept the risks.\n\n## Migrating v3 and v4 Image resources\n\nThe `dockerbuild.Image` resource provides a superset of functionality over the `Image` resources available in versions 3 and 4 of the Pulumi Docker provider.\nExisting `Image` resources can be converted to `dockerbuild.Image` resources with minor modifications.\n\n### Behavioral differences\n\nThere are several key behavioral differences to keep in mind when transitioning images to the new `dockerbuild.Image` resource.\n\n#### Previews\n\nVersion `3.x` of the Pulumi Docker provider always builds images during preview operations.\nThis is helpful as a safeguard to prevent \"broken\" images from merging, but users found the behavior unnecessarily redundant when running previews and updates locally.\n\nVersion `4.x` changed build-on-preview behavior to be opt-in.\nBy default, `v4.x` `Image` resources do _not_ build during previews, but this behavior can be toggled with the `buildOnPreview` option.\nSome users felt this made previews in CI less helpful because they no longer detected bad images by default.\n\nThe default behavior of the `dockerbuild.Image` resource has been changed to strike a better balance between CI use cases and manual updates.\nBy default, Pulumi will now only build `dockerbuild.Image` resources during previews when it detects a CI environment like GitHub Actions.\nPreviews run in non-CI environments will not build images.\nThis behavior is still configurable with `buildOnPreview`.\n\n#### Push behavior\n\nVersions `3.x` and `4.x` of the Pulumi Docker provider attempt to push images to remote registries by default.\nThey expose a `skipPush: true` option to disable pushing.\n\nThe `dockerbuild.Image` resource matches the Docker CLI's behavior and does not push images anywhere by default.\n\nTo push images to a registry you can include `push: true` (equivalent to Docker's `--push` flag) or configure an `export` of type `registry` (equivalent to Docker's `--output type=registry`).\nLike Docker, if an image is configured without exports you will see a warning with instructions for how to enable pushing, but the build will still proceed normally.\n\n#### Secrets\n\nVersion `3.x` of the Pulumi Docker provider supports secrets by way of the `extraOptions` field.\n\nVersion `4.x` of the Pulumi Docker provider does not support secrets.\n\nThe `dockerbuild.Image` resource supports secrets but does not require those secrets to exist on-disk or in environment variables.\nInstead, they should be passed directly as values.\n(Please be sure to familiarize yourself with Pulumi's [native secret handling](https://www.pulumi.com/docs/concepts/secrets/).)\nPulumi also provides [ESC](https://www.pulumi.com/product/esc/) to make it easier to share secrets across stacks and environments.\n\n#### Caching\n\nVersion `3.x` of the Pulumi Docker provider exposes `cacheFrom: bool | { stages: [...] }`.\nIt builds targets individually and pushes them to separate images for caching.\n\nVersion `4.x` exposes a similar parameter `cacheFrom: { images: [...] }` which pushes and pulls inline caches.\n\nBoth versions 3 and 4 require specific environment variables to be set and deviate from Docker's native caching behavior.\nThis can result in inefficient builds due to unnecessary image pulls, repeated file transfers, etc.\n\nThe `dockerbuild.Image` resource delegates all caching behavior to Docker.\n`cacheFrom` and `cacheTo` options (equivalent to Docker's `--cache-to` and `--cache-from`) are exposed and provide additional cache targets, such as local disk, S3 storage, etc.\n\n#### Outputs\n\nVersions `3.x` and `4.x` of the provider exposed a `repoDigest` output which was a fully qualified tag with digest.\nIn `4.x` this could also be a single sha256 hash if the image wasn't pushed.\n\nUnlike earlier providers the `dockerbuild.Image` resource can push multiple tags.\nAs a convenience, it exposes a `ref` output consisting of a tag with digest as long as the image was pushed.\nIf multiple tags were pushed this uses one at random.\n\nIf you need more control over tag references you can use the `digest` output, which is always a single sha256 hash as long as the image was exported somewhere.\n\n#### Tag deletion and refreshes\n\nVersions 3 and 4 of Pulumi Docker provider do not delete tags when the `Image` resource is deleted, nor do they confirm expected tags exist during `refresh` operations.\n\nThe `buidx.Image` will query your registries during `refresh` to ensure the expected tags exist.\nIf any are missing a subsequent `update` will push them.\n\nWhen a `dockerbuild.Image` is deleted, it will _attempt_ to also delete any pushed tags.\nDeletion of remote tags is not guaranteed because not all registries support the manifest `DELETE` API (`docker.io` in particular).\nManifests are _not_ deleted in the same way during updates -- to do so safely would require a full build to determine whether a Pulumi operation should be an update or update-replace.\n\nUse the [`retainOnDelete: true`](https://www.pulumi.com/docs/concepts/options/retainondelete/) option if you do not want tags deleted.\n\n### Example migration\n\nExamples of \"fully-featured\" `v3` and `v4` `Image` resources are shown below, along with an example `dockerbuild.Image` resource showing how they would look after migration.\n\nThe `v3` resource leverages `buildx` via a `DOCKER_BUILDKIT` environment variable and CLI flags passed in with `extraOption`.\nAfter migration, the environment variable is no longer needed and CLI flags are now properties on the `dockerbuild.Image`.\nIn almost all cases, properties of `dockerbuild.Image` are named after the Docker CLI flag they correspond to.\n\nThe `v4` resource is less functional than its `v3` counterpart because it lacks the flexibility of `extraOptions`.\nIt it is shown with parameters similar to the `v3` example for completeness.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### v3/v4 migration\n\n```typescript\n\n// v3 Image\nconst v3 = new docker.Image(\"v3-image\", {\n  imageName: \"myregistry.com/user/repo:latest\",\n  localImageName: \"local-tag\",\n  skipPush: false,\n  build: {\n    dockerfile: \"./Dockerfile\",\n    context: \"../app\",\n    target: \"mytarget\",\n    args: {\n      MY_BUILD_ARG: \"foo\",\n    },\n    env: {\n      DOCKER_BUILDKIT: \"1\",\n    },\n    extraOptions: [\n      \"--cache-from\",\n      \"type=registry,myregistry.com/user/repo:cache\",\n      \"--cache-to\",\n      \"type=registry,myregistry.com/user/repo:cache\",\n      \"--add-host\",\n      \"metadata.google.internal:169.254.169.254\",\n      \"--secret\",\n      \"id=mysecret,src=/local/secret\",\n      \"--ssh\",\n      \"default=/home/runner/.ssh/id_ed25519\",\n      \"--network\",\n      \"host\",\n      \"--platform\",\n      \"linux/amd64\",\n    ],\n  },\n  registry: {\n    server: \"myregistry.com\",\n    username: \"username\",\n    password: pulumi.secret(\"password\"),\n  },\n});\n\n// v3 Image after migrating to dockerbuild.Image\nconst v3Migrated = new dockerbuild.Image(\"v3-to-buildx\", {\n    tags: [\"myregistry.com/user/repo:latest\", \"local-tag\"],\n    push: true,\n    dockerfile: {\n        location: \"./Dockerfile\",\n    },\n    context: {\n        location: \"../app\",\n    },\n    targets: [\"mytarget\"],\n    buildArgs: {\n        MY_BUILD_ARG: \"foo\",\n    },\n    cacheFrom: [{ registry: { ref: \"myregistry.com/user/repo:cache\" } }],\n    cacheTo: [{ registry: { ref: \"myregistry.com/user/repo:cache\" } }],\n    secrets: {\n        mysecret: \"value\",\n    },\n    addHosts: [\"metadata.google.internal:169.254.169.254\"],\n    ssh: {\n        default: [\"/home/runner/.ssh/id_ed25519\"],\n    },\n    network: \"host\",\n    platforms: [\"linux/amd64\"],\n    registries: [{\n        address: \"myregistry.com\",\n        username: \"username\",\n        password: pulumi.secret(\"password\"),\n    }],\n});\n\n\n// v4 Image\nconst v4 = new docker.Image(\"v4-image\", {\n    imageName: \"myregistry.com/user/repo:latest\",\n    skipPush: false,\n    build: {\n        dockerfile: \"./Dockerfile\",\n        context: \"../app\",\n        target: \"mytarget\",\n        args: {\n            MY_BUILD_ARG: \"foo\",\n        },\n        cacheFrom: {\n            images: [\"myregistry.com/user/repo:cache\"],\n        },\n        addHosts: [\"metadata.google.internal:169.254.169.254\"],\n        network: \"host\",\n        platform: \"linux/amd64\",\n    },\n    buildOnPreview: true,\n    registry: {\n        server: \"myregistry.com\",\n        username: \"username\",\n        password: pulumi.secret(\"password\"),\n    },\n});\n\n// v4 Image after migrating to dockerbuild.Image\nconst v4Migrated = new dockerbuild.Image(\"v4-to-buildx\", {\n    tags: [\"myregistry.com/user/repo:latest\"],\n    push: true,\n    dockerfile: {\n        location: \"./Dockerfile\",\n    },\n    context: {\n        location: \"../app\",\n    },\n    targets: [\"mytarget\"],\n    buildArgs: {\n        MY_BUILD_ARG: \"foo\",\n    },\n    cacheFrom: [{ registry: { ref: \"myregistry.com/user/repo:cache\" } }],\n    cacheTo: [{ registry: { ref: \"myregistry.com/user/repo:cache\" } }],\n    addHosts: [\"metadata.google.internal:169.254.169.254\"],\n    network: \"host\",\n    platforms: [\"linux/amd64\"],\n    registries: [{\n        address: \"myregistry.com\",\n        username: \"username\",\n        password: pulumi.secret(\"password\"),\n    }],\n});\n\n```\n\n{{% /example %}}\n\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Push to AWS ECR with caching\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as aws from \"@pulumi/aws\";\nimport * as dockerbuild from \"@pulumi/dockerbuild\";\n\nconst ecrRepository = new aws.ecr.Repository(\"ecr-repository\", {});\nconst authToken = aws.ecr.getAuthorizationTokenOutput({\n    registryId: ecrRepository.registryId,\n});\nconst myImage = new dockerbuild.Image(\"my-image\", {\n    cacheFrom: [{\n        registry: {\n            ref: pulumi.interpolate`${ecrRepository.repositoryUrl}:cache`,\n        },\n    }],\n    cacheTo: [{\n        registry: {\n            imageManifest: true,\n            ociMediaTypes: true,\n            ref: pulumi.interpolate`${ecrRepository.repositoryUrl}:cache`,\n        },\n    }],\n    context: {\n        location: \"./app\",\n    },\n    push: true,\n    registries: [{\n        address: ecrRepository.repositoryUrl,\n        password: authToken.apply(authToken =\u003e authToken.password),\n        username: authToken.apply(authToken =\u003e authToken.userName),\n    }],\n    tags: [pulumi.interpolate`${ecrRepository.repositoryUrl}:latest`],\n});\nexport const ref = myImage.ref;\n```\n```python\nimport pulumi\nimport pulumi_aws as aws\nimport pulumi_dockerbuild as dockerbuild\n\necr_repository = aws.ecr.Repository(\"ecr-repository\")\nauth_token = aws.ecr.get_authorization_token_output(registry_id=ecr_repository.registry_id)\nmy_image = dockerbuild.Image(\"my-image\",\n    cache_from=[dockerbuild.CacheFromArgs(\n        registry=dockerbuild.CacheFromRegistryArgs(\n            ref=ecr_repository.repository_url.apply(lambda repository_url: f\"{repository_url}:cache\"),\n        ),\n    )],\n    cache_to=[dockerbuild.CacheToArgs(\n        registry=dockerbuild.CacheToRegistryArgs(\n            image_manifest=True,\n            oci_media_types=True,\n            ref=ecr_repository.repository_url.apply(lambda repository_url: f\"{repository_url}:cache\"),\n        ),\n    )],\n    context=dockerbuild.BuildContextArgs(\n        location=\"./app\",\n    ),\n    push=True,\n    registries=[dockerbuild.RegistryArgs(\n        address=ecr_repository.repository_url,\n        password=auth_token.password,\n        username=auth_token.user_name,\n    )],\n    tags=[ecr_repository.repository_url.apply(lambda repository_url: f\"{repository_url}:latest\")])\npulumi.export(\"ref\", my_image.ref)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Aws = Pulumi.Aws;\nusing Dockerbuild = Pulumi.Dockerbuild;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var ecrRepository = new Aws.Ecr.Repository(\"ecr-repository\");\n\n    var authToken = Aws.Ecr.GetAuthorizationToken.Invoke(new()\n    {\n        RegistryId = ecrRepository.RegistryId,\n    });\n\n    var myImage = new Dockerbuild.Image(\"my-image\", new()\n    {\n        CacheFrom = new[]\n        {\n            new Dockerbuild.Inputs.CacheFromArgs\n            {\n                Registry = new Dockerbuild.Inputs.CacheFromRegistryArgs\n                {\n                    Ref = ecrRepository.RepositoryUrl.Apply(repositoryUrl =\u003e $\"{repositoryUrl}:cache\"),\n                },\n            },\n        },\n        CacheTo = new[]\n        {\n            new Dockerbuild.Inputs.CacheToArgs\n            {\n                Registry = new Dockerbuild.Inputs.CacheToRegistryArgs\n                {\n                    ImageManifest = true,\n                    OciMediaTypes = true,\n                    Ref = ecrRepository.RepositoryUrl.Apply(repositoryUrl =\u003e $\"{repositoryUrl}:cache\"),\n                },\n            },\n        },\n        Context = new Dockerbuild.Inputs.BuildContextArgs\n        {\n            Location = \"./app\",\n        },\n        Push = true,\n        Registries = new[]\n        {\n            new Dockerbuild.Inputs.RegistryArgs\n            {\n                Address = ecrRepository.RepositoryUrl,\n                Password = authToken.Apply(getAuthorizationTokenResult =\u003e getAuthorizationTokenResult.Password),\n                Username = authToken.Apply(getAuthorizationTokenResult =\u003e getAuthorizationTokenResult.UserName),\n            },\n        },\n        Tags = new[]\n        {\n            ecrRepository.RepositoryUrl.Apply(repositoryUrl =\u003e $\"{repositoryUrl}:latest\"),\n        },\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"ref\"] = myImage.Ref,\n    };\n});\n\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi-aws/sdk/v6/go/aws/ecr\"\n\t\"github.com/pulumi/pulumi-dockerbuild/sdk/go/dockerbuild\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tecrRepository, err := ecr.NewRepository(ctx, \"ecr-repository\", nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tauthToken := ecr.GetAuthorizationTokenOutput(ctx, ecr.GetAuthorizationTokenOutputArgs{\n\t\t\tRegistryId: ecrRepository.RegistryId,\n\t\t}, nil)\n\t\tmyImage, err := dockerbuild.NewImage(ctx, \"my-image\", \u0026dockerbuild.ImageArgs{\n\t\t\tCacheFrom: dockerbuild.CacheFromArray{\n\t\t\t\t\u0026dockerbuild.CacheFromArgs{\n\t\t\t\t\tRegistry: \u0026dockerbuild.CacheFromRegistryArgs{\n\t\t\t\t\t\tRef: ecrRepository.RepositoryUrl.ApplyT(func(repositoryUrl string) (string, error) {\n\t\t\t\t\t\t\treturn fmt.Sprintf(\"%v:cache\", repositoryUrl), nil\n\t\t\t\t\t\t}).(pulumi.StringOutput),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tCacheTo: dockerbuild.CacheToArray{\n\t\t\t\t\u0026dockerbuild.CacheToArgs{\n\t\t\t\t\tRegistry: \u0026dockerbuild.CacheToRegistryArgs{\n\t\t\t\t\t\tImageManifest: pulumi.Bool(true),\n\t\t\t\t\t\tOciMediaTypes: pulumi.Bool(true),\n\t\t\t\t\t\tRef: ecrRepository.RepositoryUrl.ApplyT(func(repositoryUrl string) (string, error) {\n\t\t\t\t\t\t\treturn fmt.Sprintf(\"%v:cache\", repositoryUrl), nil\n\t\t\t\t\t\t}).(pulumi.StringOutput),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tContext: \u0026dockerbuild.BuildContextArgs{\n\t\t\t\tLocation: pulumi.String(\"./app\"),\n\t\t\t},\n\t\t\tPush: pulumi.Bool(true),\n\t\t\tRegistries: dockerbuild.RegistryArray{\n\t\t\t\t\u0026dockerbuild.RegistryArgs{\n\t\t\t\t\tAddress: ecrRepository.RepositoryUrl,\n\t\t\t\t\tPassword: authToken.ApplyT(func(authToken ecr.GetAuthorizationTokenResult) (*string, error) {\n\t\t\t\t\t\treturn \u0026authToken.Password, nil\n\t\t\t\t\t}).(pulumi.StringPtrOutput),\n\t\t\t\t\tUsername: authToken.ApplyT(func(authToken ecr.GetAuthorizationTokenResult) (*string, error) {\n\t\t\t\t\t\treturn \u0026authToken.UserName, nil\n\t\t\t\t\t}).(pulumi.StringPtrOutput),\n\t\t\t\t},\n\t\t\t},\n\t\t\tTags: pulumi.StringArray{\n\t\t\t\tecrRepository.RepositoryUrl.ApplyT(func(repositoryUrl string) (string, error) {\n\t\t\t\t\treturn fmt.Sprintf(\"%v:latest\", repositoryUrl), nil\n\t\t\t\t}).(pulumi.StringOutput),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"ref\", myImage.Ref)\n\t\treturn nil\n\t})\n}\n```\n```yaml\ndescription: Push to AWS ECR with caching\nname: ecr\noutputs:\n    ref: ${my-image.ref}\nresources:\n    ecr-repository:\n        type: aws:ecr:Repository\n    my-image:\n        properties:\n            cacheFrom:\n                - registry:\n                    ref: ${ecr-repository.repositoryUrl}:cache\n            cacheTo:\n                - registry:\n                    imageManifest: true\n                    ociMediaTypes: true\n                    ref: ${ecr-repository.repositoryUrl}:cache\n            context:\n                location: ./app\n            push: true\n            registries:\n                - address: ${ecr-repository.repositoryUrl}\n                  password: ${auth-token.password}\n                  username: ${auth-token.userName}\n            tags:\n                - ${ecr-repository.repositoryUrl}:latest\n        type: dockerbuild:Image\nruntime: yaml\nvariables:\n    auth-token:\n        fn::aws:ecr:getAuthorizationToken:\n            registryId: ${ecr-repository.registryId}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.aws.ecr.Repository;\nimport com.pulumi.aws.ecr.EcrFunctions;\nimport com.pulumi.aws.ecr.inputs.GetAuthorizationTokenArgs;\nimport com.pulumi.dockerbuild.Image;\nimport com.pulumi.dockerbuild.ImageArgs;\nimport com.pulumi.dockerbuild.inputs.CacheFromArgs;\nimport com.pulumi.dockerbuild.inputs.CacheFromRegistryArgs;\nimport com.pulumi.dockerbuild.inputs.CacheToArgs;\nimport com.pulumi.dockerbuild.inputs.CacheToRegistryArgs;\nimport com.pulumi.dockerbuild.inputs.BuildContextArgs;\nimport com.pulumi.dockerbuild.inputs.RegistryArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var ecrRepository = new Repository(\"ecrRepository\");\n\n        final var authToken = EcrFunctions.getAuthorizationToken(GetAuthorizationTokenArgs.builder()\n            .registryId(ecrRepository.registryId())\n            .build());\n\n        var myImage = new Image(\"myImage\", ImageArgs.builder()        \n            .cacheFrom(CacheFromArgs.builder()\n                .registry(CacheFromRegistryArgs.builder()\n                    .ref(ecrRepository.repositoryUrl().applyValue(repositoryUrl -\u003e String.format(\"%s:cache\", repositoryUrl)))\n                    .build())\n                .build())\n            .cacheTo(CacheToArgs.builder()\n                .registry(CacheToRegistryArgs.builder()\n                    .imageManifest(true)\n                    .ociMediaTypes(true)\n                    .ref(ecrRepository.repositoryUrl().applyValue(repositoryUrl -\u003e String.format(\"%s:cache\", repositoryUrl)))\n                    .build())\n                .build())\n            .context(BuildContextArgs.builder()\n                .location(\"./app\")\n                .build())\n            .push(true)\n            .registries(RegistryArgs.builder()\n                .address(ecrRepository.repositoryUrl())\n                .password(authToken.applyValue(getAuthorizationTokenResult -\u003e getAuthorizationTokenResult).applyValue(authToken -\u003e authToken.applyValue(getAuthorizationTokenResult -\u003e getAuthorizationTokenResult.password())))\n                .username(authToken.applyValue(getAuthorizationTokenResult -\u003e getAuthorizationTokenResult).applyValue(authToken -\u003e authToken.applyValue(getAuthorizationTokenResult -\u003e getAuthorizationTokenResult.userName())))\n                .build())\n            .tags(ecrRepository.repositoryUrl().applyValue(repositoryUrl -\u003e String.format(\"%s:latest\", repositoryUrl)))\n            .build());\n\n        ctx.export(\"ref\", myImage.ref());\n    }\n}\n```\n{{% /example %}}\n{{% example %}}\n### Multi-platform image\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as dockerbuild from \"@pulumi/dockerbuild\";\n\nconst image = new dockerbuild.Image(\"image\", {\n    context: {\n        location: \"app\",\n    },\n    platforms: [\n        dockerbuild.Platform.Plan9_amd64,\n        dockerbuild.Platform.Plan9_386,\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_dockerbuild as dockerbuild\n\nimage = dockerbuild.Image(\"image\",\n    context=dockerbuild.BuildContextArgs(\n        location=\"app\",\n    ),\n    platforms=[\n        dockerbuild.Platform.PLAN9_AMD64,\n        dockerbuild.Platform.PLAN9_386,\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Dockerbuild = Pulumi.Dockerbuild;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var image = new Dockerbuild.Image(\"image\", new()\n    {\n        Context = new Dockerbuild.Inputs.BuildContextArgs\n        {\n            Location = \"app\",\n        },\n        Platforms = new[]\n        {\n            Dockerbuild.Platform.Plan9_amd64,\n            Dockerbuild.Platform.Plan9_386,\n        },\n    });\n\n});\n\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-dockerbuild/sdk/go/dockerbuild\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := dockerbuild.NewImage(ctx, \"image\", \u0026dockerbuild.ImageArgs{\n\t\t\tContext: \u0026dockerbuild.BuildContextArgs{\n\t\t\t\tLocation: pulumi.String(\"app\"),\n\t\t\t},\n\t\t\tPlatforms: dockerbuild.PlatformArray{\n\t\t\t\tdockerbuild.Platform_Plan9_amd64,\n\t\t\t\tdockerbuild.Platform_Plan9_386,\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```yaml\ndescription: Multi-platform image\nname: multi-platform\nresources:\n    image:\n        properties:\n            context:\n                location: app\n            platforms:\n                - plan9/amd64\n                - plan9/386\n        type: dockerbuild:Image\nruntime: yaml\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.dockerbuild.Image;\nimport com.pulumi.dockerbuild.ImageArgs;\nimport com.pulumi.dockerbuild.inputs.BuildContextArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var image = new Image(\"image\", ImageArgs.builder()        \n            .context(BuildContextArgs.builder()\n                .location(\"app\")\n                .build())\n            .platforms(            \n                \"plan9/amd64\",\n                \"plan9/386\")\n            .build());\n\n    }\n}\n```\n{{% /example %}}\n{{% example %}}\n### Registry export\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as dockerbuild from \"@pulumi/dockerbuild\";\n\nconst image = new dockerbuild.Image(\"image\", {\n    context: {\n        location: \"app\",\n    },\n    push: true,\n    registries: [{\n        address: \"docker.io\",\n        password: dockerHubPassword,\n        username: \"pulumibot\",\n    }],\n    tags: [\"docker.io/pulumi/pulumi:3.107.0\"],\n});\nexport const ref = myImage.ref;\n```\n```python\nimport pulumi\nimport pulumi_dockerbuild as dockerbuild\n\nimage = dockerbuild.Image(\"image\",\n    context=dockerbuild.BuildContextArgs(\n        location=\"app\",\n    ),\n    push=True,\n    registries=[dockerbuild.RegistryArgs(\n        address=\"docker.io\",\n        password=docker_hub_password,\n        username=\"pulumibot\",\n    )],\n    tags=[\"docker.io/pulumi/pulumi:3.107.0\"])\npulumi.export(\"ref\", my_image[\"ref\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Dockerbuild = Pulumi.Dockerbuild;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var image = new Dockerbuild.Image(\"image\", new()\n    {\n        Context = new Dockerbuild.Inputs.BuildContextArgs\n        {\n            Location = \"app\",\n        },\n        Push = true,\n        Registries = new[]\n        {\n            new Dockerbuild.Inputs.RegistryArgs\n            {\n                Address = \"docker.io\",\n                Password = dockerHubPassword,\n                Username = \"pulumibot\",\n            },\n        },\n        Tags = new[]\n        {\n            \"docker.io/pulumi/pulumi:3.107.0\",\n        },\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"ref\"] = myImage.Ref,\n    };\n});\n\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-dockerbuild/sdk/go/dockerbuild\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := dockerbuild.NewImage(ctx, \"image\", \u0026dockerbuild.ImageArgs{\n\t\t\tContext: \u0026dockerbuild.BuildContextArgs{\n\t\t\t\tLocation: pulumi.String(\"app\"),\n\t\t\t},\n\t\t\tPush: pulumi.Bool(true),\n\t\t\tRegistries: dockerbuild.RegistryArray{\n\t\t\t\t\u0026dockerbuild.RegistryArgs{\n\t\t\t\t\tAddress:  pulumi.String(\"docker.io\"),\n\t\t\t\t\tPassword: pulumi.Any(dockerHubPassword),\n\t\t\t\t\tUsername: pulumi.String(\"pulumibot\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tTags: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"docker.io/pulumi/pulumi:3.107.0\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"ref\", myImage.Ref)\n\t\treturn nil\n\t})\n}\n```\n```yaml\ndescription: Registry export\nname: registry\noutputs:\n    ref: ${my-image.ref}\nresources:\n    image:\n        properties:\n            context:\n                location: app\n            push: true\n            registries:\n                - address: docker.io\n                  password: ${dockerHubPassword}\n                  username: pulumibot\n            tags:\n                - docker.io/pulumi/pulumi:3.107.0\n        type: dockerbuild:Image\nruntime: yaml\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.dockerbuild.Image;\nimport com.pulumi.dockerbuild.ImageArgs;\nimport com.pulumi.dockerbuild.inputs.BuildContextArgs;\nimport com.pulumi.dockerbuild.inputs.RegistryArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var image = new Image(\"image\", ImageArgs.builder()        \n            .context(BuildContextArgs.builder()\n                .location(\"app\")\n                .build())\n            .push(true)\n            .registries(RegistryArgs.builder()\n                .address(\"docker.io\")\n                .password(dockerHubPassword)\n                .username(\"pulumibot\")\n                .build())\n            .tags(\"docker.io/pulumi/pulumi:3.107.0\")\n            .build());\n\n        ctx.export(\"ref\", myImage.ref());\n    }\n}\n```\n{{% /example %}}\n{{% example %}}\n### Caching\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as dockerbuild from \"@pulumi/dockerbuild\";\n\nconst image = new dockerbuild.Image(\"image\", {\n    cacheFrom: [{\n        local: {\n            src: \"tmp/cache\",\n        },\n    }],\n    cacheTo: [{\n        local: {\n            dest: \"tmp/cache\",\n            mode: dockerbuild.CacheMode.Max,\n        },\n    }],\n    context: {\n        location: \"app\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_dockerbuild as dockerbuild\n\nimage = dockerbuild.Image(\"image\",\n    cache_from=[dockerbuild.CacheFromArgs(\n        local=dockerbuild.CacheFromLocalArgs(\n            src=\"tmp/cache\",\n        ),\n    )],\n    cache_to=[dockerbuild.CacheToArgs(\n        local=dockerbuild.CacheToLocalArgs(\n            dest=\"tmp/cache\",\n            mode=dockerbuild.CacheMode.MAX,\n        ),\n    )],\n    context=dockerbuild.BuildContextArgs(\n        location=\"app\",\n    ))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Dockerbuild = Pulumi.Dockerbuild;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var image = new Dockerbuild.Image(\"image\", new()\n    {\n        CacheFrom = new[]\n        {\n            new Dockerbuild.Inputs.CacheFromArgs\n            {\n                Local = new Dockerbuild.Inputs.CacheFromLocalArgs\n                {\n                    Src = \"tmp/cache\",\n                },\n            },\n        },\n        CacheTo = new[]\n        {\n            new Dockerbuild.Inputs.CacheToArgs\n            {\n                Local = new Dockerbuild.Inputs.CacheToLocalArgs\n                {\n                    Dest = \"tmp/cache\",\n                    Mode = Dockerbuild.CacheMode.Max,\n                },\n            },\n        },\n        Context = new Dockerbuild.Inputs.BuildContextArgs\n        {\n            Location = \"app\",\n        },\n    });\n\n});\n\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-dockerbuild/sdk/go/dockerbuild\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := dockerbuild.NewImage(ctx, \"image\", \u0026dockerbuild.ImageArgs{\n\t\t\tCacheFrom: dockerbuild.CacheFromArray{\n\t\t\t\t\u0026dockerbuild.CacheFromArgs{\n\t\t\t\t\tLocal: \u0026dockerbuild.CacheFromLocalArgs{\n\t\t\t\t\t\tSrc: pulumi.String(\"tmp/cache\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tCacheTo: dockerbuild.CacheToArray{\n\t\t\t\t\u0026dockerbuild.CacheToArgs{\n\t\t\t\t\tLocal: \u0026dockerbuild.CacheToLocalArgs{\n\t\t\t\t\t\tDest: pulumi.String(\"tmp/cache\"),\n\t\t\t\t\t\tMode: dockerbuild.CacheModeMax,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tContext: \u0026dockerbuild.BuildContextArgs{\n\t\t\t\tLocation: pulumi.String(\"app\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```yaml\ndescription: Caching\nname: caching\nresources:\n    image:\n        properties:\n            cacheFrom:\n                - local:\n                    src: tmp/cache\n            cacheTo:\n                - local:\n                    dest: tmp/cache\n                    mode: max\n            context:\n                location: app\n        type: dockerbuild:Image\nruntime: yaml\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.dockerbuild.Image;\nimport com.pulumi.dockerbuild.ImageArgs;\nimport com.pulumi.dockerbuild.inputs.CacheFromArgs;\nimport com.pulumi.dockerbuild.inputs.CacheFromLocalArgs;\nimport com.pulumi.dockerbuild.inputs.CacheToArgs;\nimport com.pulumi.dockerbuild.inputs.CacheToLocalArgs;\nimport com.pulumi.dockerbuild.inputs.BuildContextArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var image = new Image(\"image\", ImageArgs.builder()        \n            .cacheFrom(CacheFromArgs.builder()\n                .local(CacheFromLocalArgs.builder()\n                    .src(\"tmp/cache\")\n                    .build())\n                .build())\n            .cacheTo(CacheToArgs.builder()\n                .local(CacheToLocalArgs.builder()\n                    .dest(\"tmp/cache\")\n                    .mode(\"max\")\n                    .build())\n                .build())\n            .context(BuildContextArgs.builder()\n                .location(\"app\")\n                .build())\n            .build());\n\n    }\n}\n```\n{{% /example %}}\n{{% example %}}\n### Docker Build Cloud\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as dockerbuild from \"@pulumi/dockerbuild\";\n\nconst image = new dockerbuild.Image(\"image\", {\n    builder: {\n        name: \"cloud-builder-name\",\n    },\n    context: {\n        location: \"app\",\n    },\n    exec: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_dockerbuild as dockerbuild\n\nimage = dockerbuild.Image(\"image\",\n    builder=dockerbuild.BuilderConfigArgs(\n        name=\"cloud-builder-name\",\n    ),\n    context=dockerbuild.BuildContextArgs(\n        location=\"app\",\n    ),\n    exec_=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Dockerbuild = Pulumi.Dockerbuild;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var image = new Dockerbuild.Image(\"image\", new()\n    {\n        Builder = new Dockerbuild.Inputs.BuilderConfigArgs\n        {\n            Name = \"cloud-builder-name\",\n        },\n        Context = new Dockerbuild.Inputs.BuildContextArgs\n        {\n            Location = \"app\",\n        },\n        Exec = true,\n    });\n\n});\n\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-dockerbuild/sdk/go/dockerbuild\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := dockerbuild.NewImage(ctx, \"image\", \u0026dockerbuild.ImageArgs{\n\t\t\tBuilder: \u0026dockerbuild.BuilderConfigArgs{\n\t\t\t\tName: pulumi.String(\"cloud-builder-name\"),\n\t\t\t},\n\t\t\tContext: \u0026dockerbuild.BuildContextArgs{\n\t\t\t\tLocation: pulumi.String(\"app\"),\n\t\t\t},\n\t\t\tExec: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```yaml\ndescription: Docker Build Cloud\nname: dbc\nresources:\n    image:\n        properties:\n            builder:\n                name: cloud-builder-name\n            context:\n                location: app\n            exec: true\n        type: dockerbuild:Image\nruntime: yaml\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.dockerbuild.Image;\nimport com.pulumi.dockerbuild.ImageArgs;\nimport com.pulumi.dockerbuild.inputs.BuilderConfigArgs;\nimport com.pulumi.dockerbuild.inputs.BuildContextArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var image = new Image(\"image\", ImageArgs.builder()        \n            .builder(BuilderConfigArgs.builder()\n                .name(\"cloud-builder-name\")\n                .build())\n            .context(BuildContextArgs.builder()\n                .location(\"app\")\n                .build())\n            .exec(true)\n            .build());\n\n    }\n}\n```\n{{% /example %}}\n{{% example %}}\n### Build arguments\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as dockerbuild from \"@pulumi/dockerbuild\";\n\nconst image = new dockerbuild.Image(\"image\", {\n    buildArgs: {\n        SET_ME_TO_TRUE: \"true\",\n    },\n    context: {\n        location: \"app\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_dockerbuild as dockerbuild\n\nimage = dockerbuild.Image(\"image\",\n    build_args={\n        \"SET_ME_TO_TRUE\": \"true\",\n    },\n    context=dockerbuild.BuildContextArgs(\n        location=\"app\",\n    ))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Dockerbuild = Pulumi.Dockerbuild;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var image = new Dockerbuild.Image(\"image\", new()\n    {\n        BuildArgs = \n        {\n            { \"SET_ME_TO_TRUE\", \"true\" },\n        },\n        Context = new Dockerbuild.Inputs.BuildContextArgs\n        {\n            Location = \"app\",\n        },\n    });\n\n});\n\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-dockerbuild/sdk/go/dockerbuild\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := dockerbuild.NewImage(ctx, \"image\", \u0026dockerbuild.ImageArgs{\n\t\t\tBuildArgs: pulumi.StringMap{\n\t\t\t\t\"SET_ME_TO_TRUE\": pulumi.String(\"true\"),\n\t\t\t},\n\t\t\tContext: \u0026dockerbuild.BuildContextArgs{\n\t\t\t\tLocation: pulumi.String(\"app\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```yaml\ndescription: Build arguments\nname: build-args\nresources:\n    image:\n        properties:\n            buildArgs:\n                SET_ME_TO_TRUE: \"true\"\n            context:\n                location: app\n        type: dockerbuild:Image\nruntime: yaml\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.dockerbuild.Image;\nimport com.pulumi.dockerbuild.ImageArgs;\nimport com.pulumi.dockerbuild.inputs.BuildContextArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var image = new Image(\"image\", ImageArgs.builder()        \n            .buildArgs(Map.of(\"SET_ME_TO_TRUE\", \"true\"))\n            .context(BuildContextArgs.builder()\n                .location(\"app\")\n                .build())\n            .build());\n\n    }\n}\n```\n{{% /example %}}\n{{% example %}}\n### Build target\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as dockerbuild from \"@pulumi/dockerbuild\";\n\nconst image = new dockerbuild.Image(\"image\", {\n    context: {\n        location: \"app\",\n    },\n    target: \"build-me\",\n});\n```\n```python\nimport pulumi\nimport pulumi_dockerbuild as dockerbuild\n\nimage = dockerbuild.Image(\"image\",\n    context=dockerbuild.BuildContextArgs(\n        location=\"app\",\n    ),\n    target=\"build-me\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Dockerbuild = Pulumi.Dockerbuild;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var image = new Dockerbuild.Image(\"image\", new()\n    {\n        Context = new Dockerbuild.Inputs.BuildContextArgs\n        {\n            Location = \"app\",\n        },\n        Target = \"build-me\",\n    });\n\n});\n\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-dockerbuild/sdk/go/dockerbuild\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := dockerbuild.NewImage(ctx, \"image\", \u0026dockerbuild.ImageArgs{\n\t\t\tContext: \u0026dockerbuild.BuildContextArgs{\n\t\t\t\tLocation: pulumi.String(\"app\"),\n\t\t\t},\n\t\t\tTarget: pulumi.String(\"build-me\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```yaml\ndescription: Build target\nname: build-target\nresources:\n    image:\n        properties:\n            context:\n                location: app\n            target: build-me\n        type: dockerbuild:Image\nruntime: yaml\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.dockerbuild.Image;\nimport com.pulumi.dockerbuild.ImageArgs;\nimport com.pulumi.dockerbuild.inputs.BuildContextArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var image = new Image(\"image\", ImageArgs.builder()        \n            .context(BuildContextArgs.builder()\n                .location(\"app\")\n                .build())\n            .target(\"build-me\")\n            .build());\n\n    }\n}\n```\n{{% /example %}}\n{{% example %}}\n### Named contexts\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as dockerbuild from \"@pulumi/dockerbuild\";\n\nconst image = new dockerbuild.Image(\"image\", {context: {\n    location: \"app\",\n    named: {\n        \"golang:latest\": {\n            location: \"docker-image://golang@sha256:b8e62cf593cdaff36efd90aa3a37de268e6781a2e68c6610940c48f7cdf36984\",\n        },\n    },\n}});\n```\n```python\nimport pulumi\nimport pulumi_dockerbuild as dockerbuild\n\nimage = dockerbuild.Image(\"image\", context=dockerbuild.BuildContextArgs(\n    location=\"app\",\n    named={\n        \"golang:latest\": dockerbuild.ContextArgs(\n            location=\"docker-image://golang@sha256:b8e62cf593cdaff36efd90aa3a37de268e6781a2e68c6610940c48f7cdf36984\",\n        ),\n    },\n))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Dockerbuild = Pulumi.Dockerbuild;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var image = new Dockerbuild.Image(\"image\", new()\n    {\n        Context = new Dockerbuild.Inputs.BuildContextArgs\n        {\n            Location = \"app\",\n            Named = \n            {\n                { \"golang:latest\", new Dockerbuild.Inputs.ContextArgs\n                {\n                    Location = \"docker-image://golang@sha256:b8e62cf593cdaff36efd90aa3a37de268e6781a2e68c6610940c48f7cdf36984\",\n                } },\n            },\n        },\n    });\n\n});\n\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-dockerbuild/sdk/go/dockerbuild\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := dockerbuild.NewImage(ctx, \"image\", \u0026dockerbuild.ImageArgs{\n\t\t\tContext: \u0026dockerbuild.BuildContextArgs{\n\t\t\t\tLocation: pulumi.String(\"app\"),\n\t\t\t\tNamed: dockerbuild.ContextMap{\n\t\t\t\t\t\"golang:latest\": \u0026dockerbuild.ContextArgs{\n\t\t\t\t\t\tLocation: pulumi.String(\"docker-image://golang@sha256:b8e62cf593cdaff36efd90aa3a37de268e6781a2e68c6610940c48f7cdf36984\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```yaml\ndescription: Named contexts\nname: named-contexts\nresources:\n    image:\n        properties:\n            context:\n                location: app\n                named:\n                    golang:latest:\n                        location: docker-image://golang@sha256:b8e62cf593cdaff36efd90aa3a37de268e6781a2e68c6610940c48f7cdf36984\n        type: dockerbuild:Image\nruntime: yaml\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.dockerbuild.Image;\nimport com.pulumi.dockerbuild.ImageArgs;\nimport com.pulumi.dockerbuild.inputs.BuildContextArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var image = new Image(\"image\", ImageArgs.builder()        \n            .context(BuildContextArgs.builder()\n                .location(\"app\")\n                .named(Map.of(\"golang:latest\", Map.of(\"location\", \"docker-image://golang@sha256:b8e62cf593cdaff36efd90aa3a37de268e6781a2e68c6610940c48f7cdf36984\")))\n                .build())\n            .build());\n\n    }\n}\n```\n{{% /example %}}\n{{% example %}}\n### Remote context\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as dockerbuild from \"@pulumi/dockerbuild\";\n\nconst image = new dockerbuild.Image(\"image\", {context: {\n    location: \"https://raw.githubusercontent.com/pulumi/pulumi-docker/api-types/provider/testdata/Dockerfile\",\n}});\n```\n```python\nimport pulumi\nimport pulumi_dockerbuild as dockerbuild\n\nimage = dockerbuild.Image(\"image\", context=dockerbuild.BuildContextArgs(\n    location=\"https://raw.githubusercontent.com/pulumi/pulumi-docker/api-types/provider/testdata/Dockerfile\",\n))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Dockerbuild = Pulumi.Dockerbuild;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var image = new Dockerbuild.Image(\"image\", new()\n    {\n        Context = new Dockerbuild.Inputs.BuildContextArgs\n        {\n            Location = \"https://raw.githubusercontent.com/pulumi/pulumi-docker/api-types/provider/testdata/Dockerfile\",\n        },\n    });\n\n});\n\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-dockerbuild/sdk/go/dockerbuild\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := dockerbuild.NewImage(ctx, \"image\", \u0026dockerbuild.ImageArgs{\n\t\t\tContext: \u0026dockerbuild.BuildContextArgs{\n\t\t\t\tLocation: pulumi.String(\"https://raw.githubusercontent.com/pulumi/pulumi-docker/api-types/provider/testdata/Dockerfile\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```yaml\ndescription: Remote context\nname: remote-context\nresources:\n    image:\n        properties:\n            context:\n                location: https://raw.githubusercontent.com/pulumi/pulumi-docker/api-types/provider/testdata/Dockerfile\n        type: dockerbuild:Image\nruntime: yaml\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.dockerbuild.Image;\nimport com.pulumi.dockerbuild.ImageArgs;\nimport com.pulumi.dockerbuild.inputs.BuildContextArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var image = new Image(\"image\", ImageArgs.builder()        \n            .context(BuildContextArgs.builder()\n                .location(\"https://raw.githubusercontent.com/pulumi/pulumi-docker/api-types/provider/testdata/Dockerfile\")\n                .build())\n            .build());\n\n    }\n}\n```\n{{% /example %}}\n{{% example %}}\n### Inline Dockerfile\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as dockerbuild from \"@pulumi/dockerbuild\";\n\nconst image = new dockerbuild.Image(\"image\", {\n    context: {\n        location: \"app\",\n    },\n    dockerfile: {\n        inline: `FROM busybox\nCOPY hello.c ./\n`,\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_dockerbuild as dockerbuild\n\nimage = dockerbuild.Image(\"image\",\n    context=dockerbuild.BuildContextArgs(\n        location=\"app\",\n    ),\n    dockerfile=dockerbuild.DockerfileArgs(\n        inline=\"\"\"FROM busybox\nCOPY hello.c ./\n\"\"\",\n    ))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Dockerbuild = Pulumi.Dockerbuild;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var image = new Dockerbuild.Image(\"image\", new()\n    {\n        Context = new Dockerbuild.Inputs.BuildContextArgs\n        {\n            Location = \"app\",\n        },\n        Dockerfile = new Dockerbuild.Inputs.DockerfileArgs\n        {\n            Inline = @\"FROM busybox\nCOPY hello.c ./\n\",\n        },\n    });\n\n});\n\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-dockerbuild/sdk/go/dockerbuild\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := dockerbuild.NewImage(ctx, \"image\", \u0026dockerbuild.ImageArgs{\n\t\t\tContext: \u0026dockerbuild.BuildContextArgs{\n\t\t\t\tLocation: pulumi.String(\"app\"),\n\t\t\t},\n\t\t\tDockerfile: \u0026dockerbuild.DockerfileArgs{\n\t\t\t\tInline: pulumi.String(\"FROM busybox\\nCOPY hello.c ./\\n\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```yaml\ndescription: Inline Dockerfile\nname: inline\nresources:\n    image:\n        properties:\n            context:\n                location: app\n            dockerfile:\n                inline: |\n                    FROM busybox\n                    COPY hello.c ./\n        type: dockerbuild:Image\nruntime: yaml\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.dockerbuild.Image;\nimport com.pulumi.dockerbuild.ImageArgs;\nimport com.pulumi.dockerbuild.inputs.BuildContextArgs;\nimport com.pulumi.dockerbuild.inputs.DockerfileArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var image = new Image(\"image\", ImageArgs.builder()        \n            .context(BuildContextArgs.builder()\n                .location(\"app\")\n                .build())\n            .dockerfile(DockerfileArgs.builder()\n                .inline(\"\"\"\nFROM busybox\nCOPY hello.c ./\n                \"\"\")\n                .build())\n            .build());\n\n    }\n}\n```\n{{% /example %}}\n{{% example %}}\n### Remote context\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as dockerbuild from \"@pulumi/dockerbuild\";\n\nconst image = new dockerbuild.Image(\"image\", {\n    context: {\n        location: \"https://github.com/docker-library/hello-world.git\",\n    },\n    dockerfile: {\n        location: \"app/Dockerfile\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_dockerbuild as dockerbuild\n\nimage = dockerbuild.Image(\"image\",\n    context=dockerbuild.BuildContextArgs(\n        location=\"https://github.com/docker-library/hello-world.git\",\n    ),\n    dockerfile=dockerbuild.DockerfileArgs(\n        location=\"app/Dockerfile\",\n    ))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Dockerbuild = Pulumi.Dockerbuild;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var image = new Dockerbuild.Image(\"image\", new()\n    {\n        Context = new Dockerbuild.Inputs.BuildContextArgs\n        {\n            Location = \"https://github.com/docker-library/hello-world.git\",\n        },\n        Dockerfile = new Dockerbuild.Inputs.DockerfileArgs\n        {\n            Location = \"app/Dockerfile\",\n        },\n    });\n\n});\n\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-dockerbuild/sdk/go/dockerbuild\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := dockerbuild.NewImage(ctx, \"image\", \u0026dockerbuild.ImageArgs{\n\t\t\tContext: \u0026dockerbuild.BuildContextArgs{\n\t\t\t\tLocation: pulumi.String(\"https://github.com/docker-library/hello-world.git\"),\n\t\t\t},\n\t\t\tDockerfile: \u0026dockerbuild.DockerfileArgs{\n\t\t\t\tLocation: pulumi.String(\"app/Dockerfile\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```yaml\ndescription: Remote context\nname: remote-context\nresources:\n    image:\n        properties:\n            context:\n                location: https://github.com/docker-library/hello-world.git\n            dockerfile:\n                location: app/Dockerfile\n        type: dockerbuild:Image\nruntime: yaml\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.dockerbuild.Image;\nimport com.pulumi.dockerbuild.ImageArgs;\nimport com.pulumi.dockerbuild.inputs.BuildContextArgs;\nimport com.pulumi.dockerbuild.inputs.DockerfileArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var image = new Image(\"image\", ImageArgs.builder()        \n            .context(BuildContextArgs.builder()\n                .location(\"https://github.com/docker-library/hello-world.git\")\n                .build())\n            .dockerfile(DockerfileArgs.builder()\n                .location(\"app/Dockerfile\")\n                .build())\n            .build());\n\n    }\n}\n```\n{{% /example %}}\n{{% example %}}\n### Local export\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as dockerbuild from \"@pulumi/dockerbuild\";\n\nconst image = new dockerbuild.Image(\"image\", {\n    context: {\n        location: \"app\",\n    },\n    exports: [{\n        docker: {\n            tar: true,\n        },\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_dockerbuild as dockerbuild\n\nimage = dockerbuild.Image(\"image\",\n    context=dockerbuild.BuildContextArgs(\n        location=\"app\",\n    ),\n    exports=[dockerbuild.ExportArgs(\n        docker=dockerbuild.ExportDockerArgs(\n            tar=True,\n        ),\n    )])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Dockerbuild = Pulumi.Dockerbuild;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var image = new Dockerbuild.Image(\"image\", new()\n    {\n        Context = new Dockerbuild.Inputs.BuildContextArgs\n        {\n            Location = \"app\",\n        },\n        Exports = new[]\n        {\n            new Dockerbuild.Inputs.ExportArgs\n            {\n                Docker = new Dockerbuild.Inputs.ExportDockerArgs\n                {\n                    Tar = true,\n                },\n            },\n        },\n    });\n\n});\n\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-dockerbuild/sdk/go/dockerbuild\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := dockerbuild.NewImage(ctx, \"image\", \u0026dockerbuild.ImageArgs{\n\t\t\tContext: \u0026dockerbuild.BuildContextArgs{\n\t\t\t\tLocation: pulumi.String(\"app\"),\n\t\t\t},\n\t\t\tExports: dockerbuild.ExportArray{\n\t\t\t\t\u0026dockerbuild.ExportArgs{\n\t\t\t\t\tDocker: \u0026dockerbuild.ExportDockerArgs{\n\t\t\t\t\t\tTar: pulumi.Bool(true),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```yaml\ndescription: Local export\nname: docker-load\nresources:\n    image:\n        properties:\n            context:\n                location: app\n            exports:\n                - docker:\n                    tar: true\n        type: dockerbuild:Image\nruntime: yaml\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.dockerbuild.Image;\nimport com.pulumi.dockerbuild.ImageArgs;\nimport com.pulumi.dockerbuild.inputs.BuildContextArgs;\nimport com.pulumi.dockerbuild.inputs.ExportArgs;\nimport com.pulumi.dockerbuild.inputs.ExportDockerArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var image = new Image(\"image\", ImageArgs.builder()        \n            .context(BuildContextArgs.builder()\n                .location(\"app\")\n                .build())\n            .exports(ExportArgs.builder()\n                .docker(ExportDockerArgs.builder()\n                    .tar(true)\n                    .build())\n                .build())\n            .build());\n\n    }\n}\n```\n{{% /example %}}\n{{% /examples %}}",
      "properties": {
        "addHosts": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Custom `host:ip` mappings to use during the build.\n\nEquivalent to Docker's `--add-host` flag."
        },
        "buildArgs": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "`ARG` names and values to set during the build.\n\nThese variables are accessed like environment variables inside `RUN`\ninstructions.\n\nBuild arguments are persisted in the image, so you should use `secrets`\nif these arguments are sensitive.\n\nEquivalent to Docker's `--build-arg` flag."
        },
        "buildOnPreview": {
          "type": "boolean",
          "description": "By default, preview behavior depends on the execution environment. If\nPulumi detects the operation is running on a CI system (GitHub Actions,\nTravis CI, Azure Pipelines, etc.) then it will build images during\npreviews as a safeguard. Otherwise, if not running on CI, previews will\nnot build images.\n\nSetting this to `false` forces previews to never perform builds, and\nsetting it to `true` will always build the image during previews.\n\nImages built during previews are never exported to registries, however\ncache manifests are still exported.\n\nOn-disk Dockerfiles are always validated for syntactic correctness\nregardless of this setting."
        },
        "builder": {
          "$ref": "#/types/dockerbuild:index:BuilderConfig",
          "description": "Builder configuration."
        },
        "cacheFrom": {
          "type": "array",
          "items": {
            "$ref": "#/types/dockerbuild:index:CacheFrom"
          },
          "description": "Cache export configuration.\n\nEquivalent to Docker's `--cache-from` flag."
        },
        "cacheTo": {
          "type": "array",
          "items": {
            "$ref": "#/types/dockerbuild:index:CacheTo"
          },
          "description": "Cache import configuration.\n\nEquivalent to Docker's `--cache-to` flag."
        },
        "context": {
          "$ref": "#/types/dockerbuild:index:BuildContext",
          "description": "Build context settings.\n\nEquivalent to Docker's `PATH | URL | -` positional argument."
        },
        "contextHash": {
          "type": "string",
          "description": "A preliminary hash of the image's build context.\n\nPulumi uses this to determine if an image _may_ need to be re-built."
        },
        "digest": {
          "type": "string",
          "description": "A SHA256 digest of the image if it was exported to a registry or\nelsewhere.\n\nEmpty if the image was not exported.\n\nRegistry images can be referenced precisely as `\u003ctag\u003e@\u003cdigest\u003e`. The\n`ref` output provides one such reference as a convenience."
        },
        "dockerfile": {
          "$ref": "#/types/dockerbuild:index:Dockerfile",
          "description": "Dockerfile settings.\n\nEquivalent to Docker's `--file` flag."
        },
        "exec": {
          "type": "boolean",
          "description": "Use `exec` mode to build this image.\n\nBy default the provider embeds a v25 Docker client with v0.12 buildx\nsupport. This helps ensure consistent behavior across environments and\nis compatible with alternative build backends (e.g. `buildkitd`), but\nit may not be desirable if you require a specific version of buildx.\nFor example you may want to run a custom `docker-buildx` binary with\nsupport for [Docker Build\nCloud](https://docs.docker.com/build/cloud/setup/) (DBC).\n\nWhen this is set to `true` the provider will instead execute the\n`docker-buildx` binary directly to perform its operations. The user is\nresponsible for ensuring this binary exists, with correct permissions\nand pre-configured builders, at a path Docker expects (e.g.\n`~/.docker/cli-plugins`).\n\nDebugging `exec` mode may be more difficult as Pulumi will not be able\nto surface fine-grained errors and warnings. Additionally credentials\nare temporarily written to disk in order to provide them to the\n`docker-buildx` binary."
        },
        "exports": {
          "type": "array",
          "items": {
            "$ref": "#/types/dockerbuild:index:Export"
          },
          "description": "Controls where images are persisted after building.\n\nImages are only stored in the local cache unless `exports` are\nexplicitly configured.\n\nExporting to multiple destinations requires a daemon running BuildKit\n0.13 or later.\n\nEquivalent to Docker's `--output` flag."
        },
        "labels": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Attach arbitrary key/value metadata to the image.\n\nEquivalent to Docker's `--label` flag."
        },
        "load": {
          "type": "boolean",
          "description": "When `true` the build will automatically include a `docker` export.\n\nDefaults to `false`.\n\nEquivalent to Docker's `--load` flag."
        },
        "network": {
          "$ref": "#/types/dockerbuild:index:NetworkMode",
          "description": "Set the network mode for `RUN` instructions. Defaults to `default`.\n\nFor custom networks, configure your builder with `--driver-opt network=...`.\n\nEquivalent to Docker's `--network` flag.",
          "default": "default"
        },
        "noCache": {
          "type": "boolean",
          "description": "Do not import cache manifests when building the image.\n\nEquivalent to Docker's `--no-cache` flag."
        },
        "platforms": {
          "type": "array",
          "items": {
            "$ref": "#/types/dockerbuild:index:Platform"
          },
          "description": "Set target platform(s) for the build. Defaults to the host's platform.\n\nEquivalent to Docker's `--platform` flag."
        },
        "pull": {
          "type": "boolean",
          "description": "Always pull referenced images.\n\nEquivalent to Docker's `--pull` flag."
        },
        "push": {
          "type": "boolean",
          "description": "When `true` the build will automatically include a `registry` export.\n\nDefaults to `false`.\n\nEquivalent to Docker's `--push` flag."
        },
        "ref": {
          "type": "string",
          "description": "If the image was pushed to any registries then this will contain a\nsingle fully-qualified tag including the build's digest.\n\nIf the image had tags but was not exported, this will take on a value\nof one of those tags.\n\nThis will be empty if the image had no exports and no tags.\n\nThis is only for convenience and may not be appropriate for situations\nwhere multiple tags or registries are involved. In those cases this\noutput is not guaranteed to be stable.\n\nFor more control over tags consumed by downstream resources you should\nuse the `digest` output."
        },
        "registries": {
          "type": "array",
          "items": {
            "$ref": "#/types/dockerbuild:index:Registry"
          },
          "description": "Registry credentials. Required if reading or exporting to private\nrepositories.\n\nCredentials are kept in-memory and do not pollute pre-existing\ncredentials on the host.\n\nSimilar to `docker login`."
        },
        "secrets": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "A mapping of secret names to their corresponding values.\n\nUnlike the Docker CLI, these can be passed by value and do not need to\nexist on-disk or in environment variables.\n\nBuild arguments and environment variables are persistent in the final\nimage, so you should use this for sensitive values.\n\nSimilar to Docker's `--secret` flag."
        },
        "ssh": {
          "type": "array",
          "items": {
            "$ref": "#/types/dockerbuild:index:SSH"
          },
          "description": "SSH agent socket or keys to expose to the build.\n\nEquivalent to Docker's `--ssh` flag."
        },
        "tags": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Name and optionally a tag (format: `name:tag`).\n\nIf exporting to a registry, the name should include the fully qualified\nregistry address (e.g. `docker.io/pulumi/pulumi:latest`).\n\nEquivalent to Docker's `--tag` flag."
        },
        "target": {
          "type": "string",
          "description": "Set the target build stage(s) to build.\n\nIf not specified all targets will be built by default.\n\nEquivalent to Docker's `--target` flag."
        }
      },
      "type": "object",
      "required": [
        "contextHash",
        "digest",
        "ref"
      ],
      "inputProperties": {
        "addHosts": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Custom `host:ip` mappings to use during the build.\n\nEquivalent to Docker's `--add-host` flag."
        },
        "buildArgs": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "`ARG` names and values to set during the build.\n\nThese variables are accessed like environment variables inside `RUN`\ninstructions.\n\nBuild arguments are persisted in the image, so you should use `secrets`\nif these arguments are sensitive.\n\nEquivalent to Docker's `--build-arg` flag."
        },
        "buildOnPreview": {
          "type": "boolean",
          "description": "By default, preview behavior depends on the execution environment. If\nPulumi detects the operation is running on a CI system (GitHub Actions,\nTravis CI, Azure Pipelines, etc.) then it will build images during\npreviews as a safeguard. Otherwise, if not running on CI, previews will\nnot build images.\n\nSetting this to `false` forces previews to never perform builds, and\nsetting it to `true` will always build the image during previews.\n\nImages built during previews are never exported to registries, however\ncache manifests are still exported.\n\nOn-disk Dockerfiles are always validated for syntactic correctness\nregardless of this setting."
        },
        "builder": {
          "$ref": "#/types/dockerbuild:index:BuilderConfig",
          "description": "Builder configuration."
        },
        "cacheFrom": {
          "type": "array",
          "items": {
            "$ref": "#/types/dockerbuild:index:CacheFrom"
          },
          "description": "Cache export configuration.\n\nEquivalent to Docker's `--cache-from` flag."
        },
        "cacheTo": {
          "type": "array",
          "items": {
            "$ref": "#/types/dockerbuild:index:CacheTo"
          },
          "description": "Cache import configuration.\n\nEquivalent to Docker's `--cache-to` flag."
        },
        "context": {
          "$ref": "#/types/dockerbuild:index:BuildContext",
          "description": "Build context settings.\n\nEquivalent to Docker's `PATH | URL | -` positional argument."
        },
        "dockerfile": {
          "$ref": "#/types/dockerbuild:index:Dockerfile",
          "description": "Dockerfile settings.\n\nEquivalent to Docker's `--file` flag."
        },
        "exec": {
          "type": "boolean",
          "description": "Use `exec` mode to build this image.\n\nBy default the provider embeds a v25 Docker client with v0.12 buildx\nsupport. This helps ensure consistent behavior across environments and\nis compatible with alternative build backends (e.g. `buildkitd`), but\nit may not be desirable if you require a specific version of buildx.\nFor example you may want to run a custom `docker-buildx` binary with\nsupport for [Docker Build\nCloud](https://docs.docker.com/build/cloud/setup/) (DBC).\n\nWhen this is set to `true` the provider will instead execute the\n`docker-buildx` binary directly to perform its operations. The user is\nresponsible for ensuring this binary exists, with correct permissions\nand pre-configured builders, at a path Docker expects (e.g.\n`~/.docker/cli-plugins`).\n\nDebugging `exec` mode may be more difficult as Pulumi will not be able\nto surface fine-grained errors and warnings. Additionally credentials\nare temporarily written to disk in order to provide them to the\n`docker-buildx` binary."
        },
        "exports": {
          "type": "array",
          "items": {
            "$ref": "#/types/dockerbuild:index:Export"
          },
          "description": "Controls where images are persisted after building.\n\nImages are only stored in the local cache unless `exports` are\nexplicitly configured.\n\nExporting to multiple destinations requires a daemon running BuildKit\n0.13 or later.\n\nEquivalent to Docker's `--output` flag."
        },
        "labels": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Attach arbitrary key/value metadata to the image.\n\nEquivalent to Docker's `--label` flag."
        },
        "load": {
          "type": "boolean",
          "description": "When `true` the build will automatically include a `docker` export.\n\nDefaults to `false`.\n\nEquivalent to Docker's `--load` flag."
        },
        "network": {
          "$ref": "#/types/dockerbuild:index:NetworkMode",
          "description": "Set the network mode for `RUN` instructions. Defaults to `default`.\n\nFor custom networks, configure your builder with `--driver-opt network=...`.\n\nEquivalent to Docker's `--network` flag.",
          "default": "default"
        },
        "noCache": {
          "type": "boolean",
          "description": "Do not import cache manifests when building the image.\n\nEquivalent to Docker's `--no-cache` flag."
        },
        "platforms": {
          "type": "array",
          "items": {
            "$ref": "#/types/dockerbuild:index:Platform"
          },
          "description": "Set target platform(s) for the build. Defaults to the host's platform.\n\nEquivalent to Docker's `--platform` flag."
        },
        "pull": {
          "type": "boolean",
          "description": "Always pull referenced images.\n\nEquivalent to Docker's `--pull` flag."
        },
        "push": {
          "type": "boolean",
          "description": "When `true` the build will automatically include a `registry` export.\n\nDefaults to `false`.\n\nEquivalent to Docker's `--push` flag."
        },
        "registries": {
          "type": "array",
          "items": {
            "$ref": "#/types/dockerbuild:index:Registry"
          },
          "description": "Registry credentials. Required if reading or exporting to private\nrepositories.\n\nCredentials are kept in-memory and do not pollute pre-existing\ncredentials on the host.\n\nSimilar to `docker login`."
        },
        "secrets": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "A mapping of secret names to their corresponding values.\n\nUnlike the Docker CLI, these can be passed by value and do not need to\nexist on-disk or in environment variables.\n\nBuild arguments and environment variables are persistent in the final\nimage, so you should use this for sensitive values.\n\nSimilar to Docker's `--secret` flag."
        },
        "ssh": {
          "type": "array",
          "items": {
            "$ref": "#/types/dockerbuild:index:SSH"
          },
          "description": "SSH agent socket or keys to expose to the build.\n\nEquivalent to Docker's `--ssh` flag."
        },
        "tags": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Name and optionally a tag (format: `name:tag`).\n\nIf exporting to a registry, the name should include the fully qualified\nregistry address (e.g. `docker.io/pulumi/pulumi:latest`).\n\nEquivalent to Docker's `--tag` flag."
        },
        "target": {
          "type": "string",
          "description": "Set the target build stage(s) to build.\n\nIf not specified all targets will be built by default.\n\nEquivalent to Docker's `--target` flag."
        }
      }
    },
    "dockerbuild:index:Index": {
      "description": "An index (or manifest list) referencing one or more existing images.\n\nUseful for crafting a multi-platform image from several\nplatform-specific images.\n\nThis creates an OCI image index or a Docker manifest list depending on\nthe media types of the source images.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Multi-platform registry caching\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as dockerbuild from \"@pulumi/dockerbuild\";\n\nconst amd64 = new dockerbuild.Image(\"amd64\", {\n    cacheFrom: [{\n        registry: {\n            ref: \"docker.io/pulumi/pulumi:cache-amd64\",\n        },\n    }],\n    cacheTo: [{\n        registry: {\n            mode: dockerbuild.CacheMode.Max,\n            ref: \"docker.io/pulumi/pulumi:cache-amd64\",\n        },\n    }],\n    context: {\n        location: \"app\",\n    },\n    platforms: [dockerbuild.Platform.Linux_amd64],\n    tags: [\"docker.io/pulumi/pulumi:3.107.0-amd64\"],\n});\nconst arm64 = new dockerbuild.Image(\"arm64\", {\n    cacheFrom: [{\n        registry: {\n            ref: \"docker.io/pulumi/pulumi:cache-arm64\",\n        },\n    }],\n    cacheTo: [{\n        registry: {\n            mode: dockerbuild.CacheMode.Max,\n            ref: \"docker.io/pulumi/pulumi:cache-arm64\",\n        },\n    }],\n    context: {\n        location: \"app\",\n    },\n    platforms: [dockerbuild.Platform.Linux_arm64],\n    tags: [\"docker.io/pulumi/pulumi:3.107.0-arm64\"],\n});\nconst index = new dockerbuild.Index(\"index\", {\n    sources: [\n        amd64.ref,\n        arm64.ref,\n    ],\n    tag: \"docker.io/pulumi/pulumi:3.107.0\",\n});\nexport const ref = index.ref;\n```\n```python\nimport pulumi\nimport pulumi_dockerbuild as dockerbuild\n\namd64 = dockerbuild.Image(\"amd64\",\n    cache_from=[dockerbuild.CacheFromArgs(\n        registry=dockerbuild.CacheFromRegistryArgs(\n            ref=\"docker.io/pulumi/pulumi:cache-amd64\",\n        ),\n    )],\n    cache_to=[dockerbuild.CacheToArgs(\n        registry=dockerbuild.CacheToRegistryArgs(\n            mode=dockerbuild.CacheMode.MAX,\n            ref=\"docker.io/pulumi/pulumi:cache-amd64\",\n        ),\n    )],\n    context=dockerbuild.BuildContextArgs(\n        location=\"app\",\n    ),\n    platforms=[dockerbuild.Platform.LINUX_AMD64],\n    tags=[\"docker.io/pulumi/pulumi:3.107.0-amd64\"])\narm64 = dockerbuild.Image(\"arm64\",\n    cache_from=[dockerbuild.CacheFromArgs(\n        registry=dockerbuild.CacheFromRegistryArgs(\n            ref=\"docker.io/pulumi/pulumi:cache-arm64\",\n        ),\n    )],\n    cache_to=[dockerbuild.CacheToArgs(\n        registry=dockerbuild.CacheToRegistryArgs(\n            mode=dockerbuild.CacheMode.MAX,\n            ref=\"docker.io/pulumi/pulumi:cache-arm64\",\n        ),\n    )],\n    context=dockerbuild.BuildContextArgs(\n        location=\"app\",\n    ),\n    platforms=[dockerbuild.Platform.LINUX_ARM64],\n    tags=[\"docker.io/pulumi/pulumi:3.107.0-arm64\"])\nindex = dockerbuild.Index(\"index\",\n    sources=[\n        amd64.ref,\n        arm64.ref,\n    ],\n    tag=\"docker.io/pulumi/pulumi:3.107.0\")\npulumi.export(\"ref\", index.ref)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Dockerbuild = Pulumi.Dockerbuild;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var amd64 = new Dockerbuild.Image(\"amd64\", new()\n    {\n        CacheFrom = new[]\n        {\n            new Dockerbuild.Inputs.CacheFromArgs\n            {\n                Registry = new Dockerbuild.Inputs.CacheFromRegistryArgs\n                {\n                    Ref = \"docker.io/pulumi/pulumi:cache-amd64\",\n                },\n            },\n        },\n        CacheTo = new[]\n        {\n            new Dockerbuild.Inputs.CacheToArgs\n            {\n                Registry = new Dockerbuild.Inputs.CacheToRegistryArgs\n                {\n                    Mode = Dockerbuild.CacheMode.Max,\n                    Ref = \"docker.io/pulumi/pulumi:cache-amd64\",\n                },\n            },\n        },\n        Context = new Dockerbuild.Inputs.BuildContextArgs\n        {\n            Location = \"app\",\n        },\n        Platforms = new[]\n        {\n            Dockerbuild.Platform.Linux_amd64,\n        },\n        Tags = new[]\n        {\n            \"docker.io/pulumi/pulumi:3.107.0-amd64\",\n        },\n    });\n\n    var arm64 = new Dockerbuild.Image(\"arm64\", new()\n    {\n        CacheFrom = new[]\n        {\n            new Dockerbuild.Inputs.CacheFromArgs\n            {\n                Registry = new Dockerbuild.Inputs.CacheFromRegistryArgs\n                {\n                    Ref = \"docker.io/pulumi/pulumi:cache-arm64\",\n                },\n            },\n        },\n        CacheTo = new[]\n        {\n            new Dockerbuild.Inputs.CacheToArgs\n            {\n                Registry = new Dockerbuild.Inputs.CacheToRegistryArgs\n                {\n                    Mode = Dockerbuild.CacheMode.Max,\n                    Ref = \"docker.io/pulumi/pulumi:cache-arm64\",\n                },\n            },\n        },\n        Context = new Dockerbuild.Inputs.BuildContextArgs\n        {\n            Location = \"app\",\n        },\n        Platforms = new[]\n        {\n            Dockerbuild.Platform.Linux_arm64,\n        },\n        Tags = new[]\n        {\n            \"docker.io/pulumi/pulumi:3.107.0-arm64\",\n        },\n    });\n\n    var index = new Dockerbuild.Index(\"index\", new()\n    {\n        Sources = new[]\n        {\n            amd64.Ref,\n            arm64.Ref,\n        },\n        Tag = \"docker.io/pulumi/pulumi:3.107.0\",\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"ref\"] = index.Ref,\n    };\n});\n\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-dockerbuild/sdk/go/dockerbuild\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tamd64, err := dockerbuild.NewImage(ctx, \"amd64\", \u0026dockerbuild.ImageArgs{\n\t\t\tCacheFrom: dockerbuild.CacheFromArray{\n\t\t\t\t\u0026dockerbuild.CacheFromArgs{\n\t\t\t\t\tRegistry: \u0026dockerbuild.CacheFromRegistryArgs{\n\t\t\t\t\t\tRef: pulumi.String(\"docker.io/pulumi/pulumi:cache-amd64\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tCacheTo: dockerbuild.CacheToArray{\n\t\t\t\t\u0026dockerbuild.CacheToArgs{\n\t\t\t\t\tRegistry: \u0026dockerbuild.CacheToRegistryArgs{\n\t\t\t\t\t\tMode: dockerbuild.CacheModeMax,\n\t\t\t\t\t\tRef:  pulumi.String(\"docker.io/pulumi/pulumi:cache-amd64\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tContext: \u0026dockerbuild.BuildContextArgs{\n\t\t\t\tLocation: pulumi.String(\"app\"),\n\t\t\t},\n\t\t\tPlatforms: dockerbuild.PlatformArray{\n\t\t\t\tdockerbuild.Platform_Linux_amd64,\n\t\t\t},\n\t\t\tTags: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"docker.io/pulumi/pulumi:3.107.0-amd64\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tarm64, err := dockerbuild.NewImage(ctx, \"arm64\", \u0026dockerbuild.ImageArgs{\n\t\t\tCacheFrom: dockerbuild.CacheFromArray{\n\t\t\t\t\u0026dockerbuild.CacheFromArgs{\n\t\t\t\t\tRegistry: \u0026dockerbuild.CacheFromRegistryArgs{\n\t\t\t\t\t\tRef: pulumi.String(\"docker.io/pulumi/pulumi:cache-arm64\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tCacheTo: dockerbuild.CacheToArray{\n\t\t\t\t\u0026dockerbuild.CacheToArgs{\n\t\t\t\t\tRegistry: \u0026dockerbuild.CacheToRegistryArgs{\n\t\t\t\t\t\tMode: dockerbuild.CacheModeMax,\n\t\t\t\t\t\tRef:  pulumi.String(\"docker.io/pulumi/pulumi:cache-arm64\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tContext: \u0026dockerbuild.BuildContextArgs{\n\t\t\t\tLocation: pulumi.String(\"app\"),\n\t\t\t},\n\t\t\tPlatforms: dockerbuild.PlatformArray{\n\t\t\t\tdockerbuild.Platform_Linux_arm64,\n\t\t\t},\n\t\t\tTags: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"docker.io/pulumi/pulumi:3.107.0-arm64\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tindex, err := dockerbuild.NewIndex(ctx, \"index\", \u0026dockerbuild.IndexArgs{\n\t\t\tSources: pulumi.StringArray{\n\t\t\t\tamd64.Ref,\n\t\t\t\tarm64.Ref,\n\t\t\t},\n\t\t\tTag: pulumi.String(\"docker.io/pulumi/pulumi:3.107.0\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"ref\", index.Ref)\n\t\treturn nil\n\t})\n}\n```\n```yaml\ndescription: Multi-platform registry caching\nname: registry-caching\noutputs:\n    ref: ${index.ref}\nresources:\n    amd64:\n        properties:\n            cacheFrom:\n                - registry:\n                    ref: docker.io/pulumi/pulumi:cache-amd64\n            cacheTo:\n                - registry:\n                    mode: max\n                    ref: docker.io/pulumi/pulumi:cache-amd64\n            context:\n                location: app\n            platforms:\n                - linux/amd64\n            tags:\n                - docker.io/pulumi/pulumi:3.107.0-amd64\n        type: dockerbuild:Image\n    arm64:\n        properties:\n            cacheFrom:\n                - registry:\n                    ref: docker.io/pulumi/pulumi:cache-arm64\n            cacheTo:\n                - registry:\n                    mode: max\n                    ref: docker.io/pulumi/pulumi:cache-arm64\n            context:\n                location: app\n            platforms:\n                - linux/arm64\n            tags:\n                - docker.io/pulumi/pulumi:3.107.0-arm64\n        type: dockerbuild:Image\n    index:\n        properties:\n            sources:\n                - ${amd64.ref}\n                - ${arm64.ref}\n            tag: docker.io/pulumi/pulumi:3.107.0\n        type: dockerbuild:Index\nruntime: yaml\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.dockerbuild.Image;\nimport com.pulumi.dockerbuild.ImageArgs;\nimport com.pulumi.dockerbuild.inputs.CacheFromArgs;\nimport com.pulumi.dockerbuild.inputs.CacheFromRegistryArgs;\nimport com.pulumi.dockerbuild.inputs.CacheToArgs;\nimport com.pulumi.dockerbuild.inputs.CacheToRegistryArgs;\nimport com.pulumi.dockerbuild.inputs.BuildContextArgs;\nimport com.pulumi.dockerbuild.Index;\nimport com.pulumi.dockerbuild.IndexArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var amd64 = new Image(\"amd64\", ImageArgs.builder()        \n            .cacheFrom(CacheFromArgs.builder()\n                .registry(CacheFromRegistryArgs.builder()\n                    .ref(\"docker.io/pulumi/pulumi:cache-amd64\")\n                    .build())\n                .build())\n            .cacheTo(CacheToArgs.builder()\n                .registry(CacheToRegistryArgs.builder()\n                    .mode(\"max\")\n                    .ref(\"docker.io/pulumi/pulumi:cache-amd64\")\n                    .build())\n                .build())\n            .context(BuildContextArgs.builder()\n                .location(\"app\")\n                .build())\n            .platforms(\"linux/amd64\")\n            .tags(\"docker.io/pulumi/pulumi:3.107.0-amd64\")\n            .build());\n\n        var arm64 = new Image(\"arm64\", ImageArgs.builder()        \n            .cacheFrom(CacheFromArgs.builder()\n                .registry(CacheFromRegistryArgs.builder()\n                    .ref(\"docker.io/pulumi/pulumi:cache-arm64\")\n                    .build())\n                .build())\n            .cacheTo(CacheToArgs.builder()\n                .registry(CacheToRegistryArgs.builder()\n                    .mode(\"max\")\n                    .ref(\"docker.io/pulumi/pulumi:cache-arm64\")\n                    .build())\n                .build())\n            .context(BuildContextArgs.builder()\n                .location(\"app\")\n                .build())\n            .platforms(\"linux/arm64\")\n            .tags(\"docker.io/pulumi/pulumi:3.107.0-arm64\")\n            .build());\n\n        var index = new Index(\"index\", IndexArgs.builder()        \n            .sources(            \n                amd64.ref(),\n                arm64.ref())\n            .tag(\"docker.io/pulumi/pulumi:3.107.0\")\n            .build());\n\n        ctx.export(\"ref\", index.ref());\n    }\n}\n```\n{{% /example %}}\n{{% /examples %}}",
      "properties": {
        "push": {
          "type": "boolean",
          "description": "If true, push the index to the target registry.\n\nDefaults to `true`.",
          "default": true
        },
        "ref": {
          "type": "string",
          "description": "The pushed tag with digest.\n\nIdentical to the tag if the index was not pushed."
        },
        "registry": {
          "$ref": "#/types/dockerbuild:index:Registry",
          "description": "Authentication for the registry where the tagged index will be pushed.\n\nCredentials can also be included with the provider's configuration."
        },
        "sources": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Existing images to include in the index."
        },
        "tag": {
          "type": "string",
          "description": "The tag to apply to the index."
        }
      },
      "type": "object",
      "required": [
        "ref",
        "sources",
        "tag"
      ],
      "inputProperties": {
        "push": {
          "type": "boolean",
          "description": "If true, push the index to the target registry.\n\nDefaults to `true`.",
          "default": true
        },
        "registry": {
          "$ref": "#/types/dockerbuild:index:Registry",
          "description": "Authentication for the registry where the tagged index will be pushed.\n\nCredentials can also be included with the provider's configuration."
        },
        "sources": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Existing images to include in the index."
        },
        "tag": {
          "type": "string",
          "description": "The tag to apply to the index."
        }
      },
      "requiredInputs": [
        "sources",
        "tag"
      ]
    }
  }
}
