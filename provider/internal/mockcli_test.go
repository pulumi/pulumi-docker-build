// Code generated by MockGen. DO NOT EDIT.
// Source: cli.go
//
// Generated by this command:
//
//	mockgen -typed -package internal -source cli.go -destination mockcli_test.go --self_package github.com/pulumi/pulumi-docker-build/provider/internal
//

// Package internal is a generated GoMock package.
package internal

import (
	reflect "reflect"

	command "github.com/docker/cli/cli/command"
	configfile "github.com/docker/cli/cli/config/configfile"
	docker "github.com/docker/cli/cli/context/docker"
	store "github.com/docker/cli/cli/context/store"
	store0 "github.com/docker/cli/cli/manifest/store"
	client "github.com/docker/cli/cli/registry/client"
	streams "github.com/docker/cli/cli/streams"
	trust "github.com/docker/cli/cli/trust"
	client0 "github.com/docker/docker/client"
	client1 "github.com/theupdateframework/notary/client"
	metric "go.opentelemetry.io/otel/metric"
	resource "go.opentelemetry.io/otel/sdk/resource"
	trace "go.opentelemetry.io/otel/trace"
	gomock "go.uber.org/mock/gomock"
)

// MockCli is a mock of Cli interface.
type MockCli struct {
	ctrl     *gomock.Controller
	recorder *MockCliMockRecorder
}

// MockCliMockRecorder is the mock recorder for MockCli.
type MockCliMockRecorder struct {
	mock *MockCli
}

// NewMockCli creates a new mock instance.
func NewMockCli(ctrl *gomock.Controller) *MockCli {
	mock := &MockCli{ctrl: ctrl}
	mock.recorder = &MockCliMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCli) EXPECT() *MockCliMockRecorder {
	return m.recorder
}

// Apply mocks base method.
func (m *MockCli) Apply(ops ...command.CLIOption) error {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range ops {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Apply", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Apply indicates an expected call of Apply.
func (mr *MockCliMockRecorder) Apply(ops ...any) *MockCliApplyCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Apply", reflect.TypeOf((*MockCli)(nil).Apply), ops...)
	return &MockCliApplyCall{Call: call}
}

// MockCliApplyCall wrap *gomock.Call
type MockCliApplyCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCliApplyCall) Return(arg0 error) *MockCliApplyCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCliApplyCall) Do(f func(...command.CLIOption) error) *MockCliApplyCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCliApplyCall) DoAndReturn(f func(...command.CLIOption) error) *MockCliApplyCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// BuildKitEnabled mocks base method.
func (m *MockCli) BuildKitEnabled() (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BuildKitEnabled")
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BuildKitEnabled indicates an expected call of BuildKitEnabled.
func (mr *MockCliMockRecorder) BuildKitEnabled() *MockCliBuildKitEnabledCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BuildKitEnabled", reflect.TypeOf((*MockCli)(nil).BuildKitEnabled))
	return &MockCliBuildKitEnabledCall{Call: call}
}

// MockCliBuildKitEnabledCall wrap *gomock.Call
type MockCliBuildKitEnabledCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCliBuildKitEnabledCall) Return(arg0 bool, arg1 error) *MockCliBuildKitEnabledCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCliBuildKitEnabledCall) Do(f func() (bool, error)) *MockCliBuildKitEnabledCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCliBuildKitEnabledCall) DoAndReturn(f func() (bool, error)) *MockCliBuildKitEnabledCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Client mocks base method.
func (m *MockCli) Client() client0.APIClient {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Client")
	ret0, _ := ret[0].(client0.APIClient)
	return ret0
}

// Client indicates an expected call of Client.
func (mr *MockCliMockRecorder) Client() *MockCliClientCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Client", reflect.TypeOf((*MockCli)(nil).Client))
	return &MockCliClientCall{Call: call}
}

// MockCliClientCall wrap *gomock.Call
type MockCliClientCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCliClientCall) Return(arg0 client0.APIClient) *MockCliClientCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCliClientCall) Do(f func() client0.APIClient) *MockCliClientCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCliClientCall) DoAndReturn(f func() client0.APIClient) *MockCliClientCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ConfigFile mocks base method.
func (m *MockCli) ConfigFile() *configfile.ConfigFile {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ConfigFile")
	ret0, _ := ret[0].(*configfile.ConfigFile)
	return ret0
}

// ConfigFile indicates an expected call of ConfigFile.
func (mr *MockCliMockRecorder) ConfigFile() *MockCliConfigFileCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ConfigFile", reflect.TypeOf((*MockCli)(nil).ConfigFile))
	return &MockCliConfigFileCall{Call: call}
}

// MockCliConfigFileCall wrap *gomock.Call
type MockCliConfigFileCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCliConfigFileCall) Return(arg0 *configfile.ConfigFile) *MockCliConfigFileCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCliConfigFileCall) Do(f func() *configfile.ConfigFile) *MockCliConfigFileCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCliConfigFileCall) DoAndReturn(f func() *configfile.ConfigFile) *MockCliConfigFileCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ContentTrustEnabled mocks base method.
func (m *MockCli) ContentTrustEnabled() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ContentTrustEnabled")
	ret0, _ := ret[0].(bool)
	return ret0
}

// ContentTrustEnabled indicates an expected call of ContentTrustEnabled.
func (mr *MockCliMockRecorder) ContentTrustEnabled() *MockCliContentTrustEnabledCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ContentTrustEnabled", reflect.TypeOf((*MockCli)(nil).ContentTrustEnabled))
	return &MockCliContentTrustEnabledCall{Call: call}
}

// MockCliContentTrustEnabledCall wrap *gomock.Call
type MockCliContentTrustEnabledCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCliContentTrustEnabledCall) Return(arg0 bool) *MockCliContentTrustEnabledCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCliContentTrustEnabledCall) Do(f func() bool) *MockCliContentTrustEnabledCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCliContentTrustEnabledCall) DoAndReturn(f func() bool) *MockCliContentTrustEnabledCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ContextStore mocks base method.
func (m *MockCli) ContextStore() store.Store {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ContextStore")
	ret0, _ := ret[0].(store.Store)
	return ret0
}

// ContextStore indicates an expected call of ContextStore.
func (mr *MockCliMockRecorder) ContextStore() *MockCliContextStoreCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ContextStore", reflect.TypeOf((*MockCli)(nil).ContextStore))
	return &MockCliContextStoreCall{Call: call}
}

// MockCliContextStoreCall wrap *gomock.Call
type MockCliContextStoreCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCliContextStoreCall) Return(arg0 store.Store) *MockCliContextStoreCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCliContextStoreCall) Do(f func() store.Store) *MockCliContextStoreCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCliContextStoreCall) DoAndReturn(f func() store.Store) *MockCliContextStoreCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CurrentContext mocks base method.
func (m *MockCli) CurrentContext() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CurrentContext")
	ret0, _ := ret[0].(string)
	return ret0
}

// CurrentContext indicates an expected call of CurrentContext.
func (mr *MockCliMockRecorder) CurrentContext() *MockCliCurrentContextCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CurrentContext", reflect.TypeOf((*MockCli)(nil).CurrentContext))
	return &MockCliCurrentContextCall{Call: call}
}

// MockCliCurrentContextCall wrap *gomock.Call
type MockCliCurrentContextCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCliCurrentContextCall) Return(arg0 string) *MockCliCurrentContextCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCliCurrentContextCall) Do(f func() string) *MockCliCurrentContextCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCliCurrentContextCall) DoAndReturn(f func() string) *MockCliCurrentContextCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CurrentVersion mocks base method.
func (m *MockCli) CurrentVersion() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CurrentVersion")
	ret0, _ := ret[0].(string)
	return ret0
}

// CurrentVersion indicates an expected call of CurrentVersion.
func (mr *MockCliMockRecorder) CurrentVersion() *MockCliCurrentVersionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CurrentVersion", reflect.TypeOf((*MockCli)(nil).CurrentVersion))
	return &MockCliCurrentVersionCall{Call: call}
}

// MockCliCurrentVersionCall wrap *gomock.Call
type MockCliCurrentVersionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCliCurrentVersionCall) Return(arg0 string) *MockCliCurrentVersionCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCliCurrentVersionCall) Do(f func() string) *MockCliCurrentVersionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCliCurrentVersionCall) DoAndReturn(f func() string) *MockCliCurrentVersionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// DefaultVersion mocks base method.
func (m *MockCli) DefaultVersion() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DefaultVersion")
	ret0, _ := ret[0].(string)
	return ret0
}

// DefaultVersion indicates an expected call of DefaultVersion.
func (mr *MockCliMockRecorder) DefaultVersion() *MockCliDefaultVersionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DefaultVersion", reflect.TypeOf((*MockCli)(nil).DefaultVersion))
	return &MockCliDefaultVersionCall{Call: call}
}

// MockCliDefaultVersionCall wrap *gomock.Call
type MockCliDefaultVersionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCliDefaultVersionCall) Return(arg0 string) *MockCliDefaultVersionCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCliDefaultVersionCall) Do(f func() string) *MockCliDefaultVersionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCliDefaultVersionCall) DoAndReturn(f func() string) *MockCliDefaultVersionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// DockerEndpoint mocks base method.
func (m *MockCli) DockerEndpoint() docker.Endpoint {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DockerEndpoint")
	ret0, _ := ret[0].(docker.Endpoint)
	return ret0
}

// DockerEndpoint indicates an expected call of DockerEndpoint.
func (mr *MockCliMockRecorder) DockerEndpoint() *MockCliDockerEndpointCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DockerEndpoint", reflect.TypeOf((*MockCli)(nil).DockerEndpoint))
	return &MockCliDockerEndpointCall{Call: call}
}

// MockCliDockerEndpointCall wrap *gomock.Call
type MockCliDockerEndpointCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCliDockerEndpointCall) Return(arg0 docker.Endpoint) *MockCliDockerEndpointCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCliDockerEndpointCall) Do(f func() docker.Endpoint) *MockCliDockerEndpointCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCliDockerEndpointCall) DoAndReturn(f func() docker.Endpoint) *MockCliDockerEndpointCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Err mocks base method.
func (m *MockCli) Err() *streams.Out {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Err")
	ret0, _ := ret[0].(*streams.Out)
	return ret0
}

// Err indicates an expected call of Err.
func (mr *MockCliMockRecorder) Err() *MockCliErrCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Err", reflect.TypeOf((*MockCli)(nil).Err))
	return &MockCliErrCall{Call: call}
}

// MockCliErrCall wrap *gomock.Call
type MockCliErrCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCliErrCall) Return(arg0 *streams.Out) *MockCliErrCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCliErrCall) Do(f func() *streams.Out) *MockCliErrCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCliErrCall) DoAndReturn(f func() *streams.Out) *MockCliErrCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// In mocks base method.
func (m *MockCli) In() *streams.In {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "In")
	ret0, _ := ret[0].(*streams.In)
	return ret0
}

// In indicates an expected call of In.
func (mr *MockCliMockRecorder) In() *MockCliInCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "In", reflect.TypeOf((*MockCli)(nil).In))
	return &MockCliInCall{Call: call}
}

// MockCliInCall wrap *gomock.Call
type MockCliInCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCliInCall) Return(arg0 *streams.In) *MockCliInCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCliInCall) Do(f func() *streams.In) *MockCliInCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCliInCall) DoAndReturn(f func() *streams.In) *MockCliInCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ManifestStore mocks base method.
func (m *MockCli) ManifestStore() store0.Store {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ManifestStore")
	ret0, _ := ret[0].(store0.Store)
	return ret0
}

// ManifestStore indicates an expected call of ManifestStore.
func (mr *MockCliMockRecorder) ManifestStore() *MockCliManifestStoreCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ManifestStore", reflect.TypeOf((*MockCli)(nil).ManifestStore))
	return &MockCliManifestStoreCall{Call: call}
}

// MockCliManifestStoreCall wrap *gomock.Call
type MockCliManifestStoreCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCliManifestStoreCall) Return(arg0 store0.Store) *MockCliManifestStoreCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCliManifestStoreCall) Do(f func() store0.Store) *MockCliManifestStoreCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCliManifestStoreCall) DoAndReturn(f func() store0.Store) *MockCliManifestStoreCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MeterProvider mocks base method.
func (m *MockCli) MeterProvider() metric.MeterProvider {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MeterProvider")
	ret0, _ := ret[0].(metric.MeterProvider)
	return ret0
}

// MeterProvider indicates an expected call of MeterProvider.
func (mr *MockCliMockRecorder) MeterProvider() *MockCliMeterProviderCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MeterProvider", reflect.TypeOf((*MockCli)(nil).MeterProvider))
	return &MockCliMeterProviderCall{Call: call}
}

// MockCliMeterProviderCall wrap *gomock.Call
type MockCliMeterProviderCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCliMeterProviderCall) Return(arg0 metric.MeterProvider) *MockCliMeterProviderCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCliMeterProviderCall) Do(f func() metric.MeterProvider) *MockCliMeterProviderCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCliMeterProviderCall) DoAndReturn(f func() metric.MeterProvider) *MockCliMeterProviderCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// NotaryClient mocks base method.
func (m *MockCli) NotaryClient(imgRefAndAuth trust.ImageRefAndAuth, actions []string) (client1.Repository, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NotaryClient", imgRefAndAuth, actions)
	ret0, _ := ret[0].(client1.Repository)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// NotaryClient indicates an expected call of NotaryClient.
func (mr *MockCliMockRecorder) NotaryClient(imgRefAndAuth, actions any) *MockCliNotaryClientCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NotaryClient", reflect.TypeOf((*MockCli)(nil).NotaryClient), imgRefAndAuth, actions)
	return &MockCliNotaryClientCall{Call: call}
}

// MockCliNotaryClientCall wrap *gomock.Call
type MockCliNotaryClientCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCliNotaryClientCall) Return(arg0 client1.Repository, arg1 error) *MockCliNotaryClientCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCliNotaryClientCall) Do(f func(trust.ImageRefAndAuth, []string) (client1.Repository, error)) *MockCliNotaryClientCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCliNotaryClientCall) DoAndReturn(f func(trust.ImageRefAndAuth, []string) (client1.Repository, error)) *MockCliNotaryClientCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Out mocks base method.
func (m *MockCli) Out() *streams.Out {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Out")
	ret0, _ := ret[0].(*streams.Out)
	return ret0
}

// Out indicates an expected call of Out.
func (mr *MockCliMockRecorder) Out() *MockCliOutCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Out", reflect.TypeOf((*MockCli)(nil).Out))
	return &MockCliOutCall{Call: call}
}

// MockCliOutCall wrap *gomock.Call
type MockCliOutCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCliOutCall) Return(arg0 *streams.Out) *MockCliOutCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCliOutCall) Do(f func() *streams.Out) *MockCliOutCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCliOutCall) DoAndReturn(f func() *streams.Out) *MockCliOutCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RegistryClient mocks base method.
func (m *MockCli) RegistryClient(arg0 bool) client.RegistryClient {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RegistryClient", arg0)
	ret0, _ := ret[0].(client.RegistryClient)
	return ret0
}

// RegistryClient indicates an expected call of RegistryClient.
func (mr *MockCliMockRecorder) RegistryClient(arg0 any) *MockCliRegistryClientCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RegistryClient", reflect.TypeOf((*MockCli)(nil).RegistryClient), arg0)
	return &MockCliRegistryClientCall{Call: call}
}

// MockCliRegistryClientCall wrap *gomock.Call
type MockCliRegistryClientCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCliRegistryClientCall) Return(arg0 client.RegistryClient) *MockCliRegistryClientCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCliRegistryClientCall) Do(f func(bool) client.RegistryClient) *MockCliRegistryClientCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCliRegistryClientCall) DoAndReturn(f func(bool) client.RegistryClient) *MockCliRegistryClientCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Resource mocks base method.
func (m *MockCli) Resource() *resource.Resource {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Resource")
	ret0, _ := ret[0].(*resource.Resource)
	return ret0
}

// Resource indicates an expected call of Resource.
func (mr *MockCliMockRecorder) Resource() *MockCliResourceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Resource", reflect.TypeOf((*MockCli)(nil).Resource))
	return &MockCliResourceCall{Call: call}
}

// MockCliResourceCall wrap *gomock.Call
type MockCliResourceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCliResourceCall) Return(arg0 *resource.Resource) *MockCliResourceCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCliResourceCall) Do(f func() *resource.Resource) *MockCliResourceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCliResourceCall) DoAndReturn(f func() *resource.Resource) *MockCliResourceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ServerInfo mocks base method.
func (m *MockCli) ServerInfo() command.ServerInfo {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ServerInfo")
	ret0, _ := ret[0].(command.ServerInfo)
	return ret0
}

// ServerInfo indicates an expected call of ServerInfo.
func (mr *MockCliMockRecorder) ServerInfo() *MockCliServerInfoCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ServerInfo", reflect.TypeOf((*MockCli)(nil).ServerInfo))
	return &MockCliServerInfoCall{Call: call}
}

// MockCliServerInfoCall wrap *gomock.Call
type MockCliServerInfoCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCliServerInfoCall) Return(arg0 command.ServerInfo) *MockCliServerInfoCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCliServerInfoCall) Do(f func() command.ServerInfo) *MockCliServerInfoCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCliServerInfoCall) DoAndReturn(f func() command.ServerInfo) *MockCliServerInfoCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetIn mocks base method.
func (m *MockCli) SetIn(in *streams.In) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetIn", in)
}

// SetIn indicates an expected call of SetIn.
func (mr *MockCliMockRecorder) SetIn(in any) *MockCliSetInCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetIn", reflect.TypeOf((*MockCli)(nil).SetIn), in)
	return &MockCliSetInCall{Call: call}
}

// MockCliSetInCall wrap *gomock.Call
type MockCliSetInCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCliSetInCall) Return() *MockCliSetInCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCliSetInCall) Do(f func(*streams.In)) *MockCliSetInCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCliSetInCall) DoAndReturn(f func(*streams.In)) *MockCliSetInCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TracerProvider mocks base method.
func (m *MockCli) TracerProvider() trace.TracerProvider {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TracerProvider")
	ret0, _ := ret[0].(trace.TracerProvider)
	return ret0
}

// TracerProvider indicates an expected call of TracerProvider.
func (mr *MockCliMockRecorder) TracerProvider() *MockCliTracerProviderCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TracerProvider", reflect.TypeOf((*MockCli)(nil).TracerProvider))
	return &MockCliTracerProviderCall{Call: call}
}

// MockCliTracerProviderCall wrap *gomock.Call
type MockCliTracerProviderCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCliTracerProviderCall) Return(arg0 trace.TracerProvider) *MockCliTracerProviderCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCliTracerProviderCall) Do(f func() trace.TracerProvider) *MockCliTracerProviderCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCliTracerProviderCall) DoAndReturn(f func() trace.TracerProvider) *MockCliTracerProviderCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
